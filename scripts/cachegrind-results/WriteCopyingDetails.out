--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         6291456 B, 64 B, 12-way associative
Command:          ./build/fluid/fluid 10 res/large.fld res/final.fld
Data file:        cachegrind-large.out
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                  I1mr           ILmr           Dr                  D1mr             DLmr           Dw                  D1mw             DLmw             
--------------------------------------------------------------------------------
49,587,075 (100.0%) 3,192 (100.0%) 2,675 (100.0%) 17,642,595 (100.0%) 174,824 (100.0%) 9,780 (100.0%) 13,469,453 (100.0%) 150,082 (100.0%) 100,340 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                 I1mr         ILmr         Dr               D1mr            DLmr           Dw               D1mw            DLmw             file:function
--------------------------------------------------------------------------------
1,877,200 ( 3.79%)  15 ( 0.47%)  15 ( 0.56%) 499,569 ( 2.83%)  8,518 ( 4.87%)     0          408,747 ( 3.03%)      1 ( 0.00%)      0           /home/alumnos/a0432481/ArquiCompP1/sim/file/fld.cpp:sim::ifld::ReadParticles()
1,862,007 ( 3.76%)  10 ( 0.31%)  10 ( 0.37%) 423,870 ( 2.40%) 26,492 (15.15%)     0          499,569 ( 3.71%)      1 ( 0.00%)      0           /home/alumnos/a0432481/ArquiCompP1/sim/file/fld.cpp:sim::ofld::WriteParticles(std::vector<sim::Particle, std::allocator<sim::Particle> >&)
1,647,623 ( 3.32%)  12 ( 0.38%)  12 ( 0.45%) 704,775 ( 3.99%) 15,226 ( 8.71%)     1 ( 0.01%) 139,849 ( 1.04%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/grid.cpp:sim::Grid::GetBlockIndex(sim::vec3&) const
1,634,904 ( 3.30%)   2 ( 0.06%)   1 ( 0.04%) 544,968 ( 3.09%)      0              0          544,968 ( 4.05%)      0               0           /usr/include/c++/10/array:std::array<float, 9ul>::operator[](unsigned long)
1,548,314 ( 3.12%)   4 ( 0.13%)   3 ( 0.11%) 740,498 ( 4.20%) 41,551 (23.77%)     0          504,885 ( 3.75%) 32,318 (21.53%) 22,223 (22.15%)  /home/alumnos/a0432481/ArquiCompP1/sim/grid/particle.cpp:sim::Particle::Particle(sim::Particle const&)
1,498,662 ( 3.02%)   0            0          681,210 ( 3.86%)      0              0          408,726 ( 3.03%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<float, std::allocator<float> >::operator[](unsigned long)
1,362,420 ( 2.75%)   2 ( 0.06%)   2 ( 0.07%) 544,968 ( 3.09%)      0              0          408,726 ( 3.03%)      0               0           /usr/include/c++/10/array:std::__array_traits<float, 9ul>::_S_ref(float const (&) [9], unsigned long)
1,147,980 ( 2.32%)   2 ( 0.06%)   1 ( 0.04%) 422,940 ( 2.40%)      0              0          362,520 ( 2.69%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:bool __gnu_cxx::operator==<sim::Particle*, sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >(__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > > const&, __gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > > const&)
1,089,950 ( 2.20%)   1 ( 0.03%)   1 ( 0.04%) 681,216 ( 3.86%)      1 ( 0.00%)     0          136,247 ( 1.01%)  8,515 ( 5.67%)  8,515 ( 8.49%)  /usr/include/c++/10/bits/stl_algobase.h:__gnu_cxx::__enable_if<std::__is_scalar<float>::__value, void>::__type std::__fill_a1<float*, float>(float*, float*, float const&)
1,046,125 ( 2.11%)   9 ( 0.28%)   9 ( 0.34%) 334,760 ( 1.90%)      0              0          276,177 ( 2.05%)      0               0           /usr/include/c++/10/bits/vector.tcc:void std::vector<sim::Particle, std::allocator<sim::Particle> >::_M_realloc_insert<sim::Particle const&>(__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >, sim::Particle const&)
  973,990 ( 1.96%)  14 ( 0.44%)  14 ( 0.52%) 163,967 ( 0.93%)  2,091 ( 1.20%) 1,708 (17.46%)  49,633 ( 0.37%)     41 ( 0.03%)      5 ( 0.00%)  ./elf/dl-lookup.c:_dl_lookup_symbol_x
  953,694 ( 1.92%)   1 ( 0.03%)   1 ( 0.04%) 363,312 ( 2.06%)      0              0          363,312 ( 2.70%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/../sim/utils/vector.hpp:sim::vec3::vec3<float>(float, float, float)
  948,947 ( 1.91%)   8 ( 0.25%)   8 ( 0.30%)  90,438 ( 0.51%) 11,848 ( 6.78%)    11 ( 0.11%) 255,894 ( 1.90%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/simulator.cpp:sim::Simulator::StoreResults()
  925,896 ( 1.87%)   1 ( 0.03%)   1 ( 0.04%) 462,948 ( 2.62%)      0              0          308,632 ( 2.29%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >::base() const
  908,325 ( 1.83%)   3 ( 0.09%)   1 ( 0.04%) 302,775 ( 1.72%)      0              0          302,775 ( 2.25%)      1 ( 0.00%)      0           /home/alumnos/a0432481/ArquiCompP1/sim/utils/vector.cpp:sim::vec3::vec3()
  878,382 ( 1.77%)   3 ( 0.09%)   2 ( 0.07%) 390,392 ( 2.21%)      0              0          390,392 ( 2.90%) 17,754 (11.83%) 14,445 (14.40%)  /home/alumnos/a0432481/ArquiCompP1/sim/utils/vector.hpp:sim::vec3::vec3(double, double, double)
  878,004 ( 1.77%)   4 ( 0.13%)   4 ( 0.15%) 317,898 ( 1.80%)      0              0          257,346 ( 1.91%)      0               0           /usr/include/c++/10/bits/vector.tcc:sim::Particle& std::vector<sim::Particle, std::allocator<sim::Particle> >::emplace_back<unsigned long, sim::vec3&, sim::vec3&, sim::vec3&>(unsigned long&&, sim::vec3&, sim::vec3&, sim::vec3&)
  847,286 ( 1.71%)   1 ( 0.03%)   0          385,130 ( 2.18%)  5,628 ( 3.22%) 1,016 (10.39%) 308,104 ( 2.29%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >::__normal_iterator(sim::Particle* const&)
  817,452 ( 1.65%)   1 ( 0.03%)   1 ( 0.04%) 408,726 ( 2.32%)      0              0          272,484 ( 2.02%)      0               0           /usr/include/c++/10/bits/move.h:sim::vec3& std::forward<sim::vec3&>(std::remove_reference<sim::vec3&>::type&)
  756,900 ( 1.53%)   2 ( 0.06%)   2 ( 0.07%) 211,932 ( 1.20%)      0              0          272,484 ( 2.02%)      0               0           /usr/include/c++/10/bits/stl_construct.h:decltype (::new ((void*)(0)) sim::Particle((declval<unsigned long>)(), (declval<sim::vec3&>)(), (declval<sim::vec3&>)(), (declval<sim::vec3&>)())) std::construct_at<sim::Particle, unsigned long, sim::vec3&, sim::vec3&, sim::vec3&>(sim::Particle*, unsigned long&&, sim::vec3&, sim::vec3&, sim::vec3&)
  726,624 ( 1.47%)   4 ( 0.13%)   4 ( 0.15%) 317,898 ( 1.80%)      0              0          272,484 ( 2.02%) 18,923 (12.61%) 18,923 (18.86%)  /home/alumnos/a0432481/ArquiCompP1/sim/grid/particle.cpp:sim::Particle::Particle(unsigned long, sim::vec3&, sim::vec3&, sim::vec3&)
  668,276 ( 1.35%)   6 ( 0.19%)   6 ( 0.22%) 182,011 ( 1.03%)     10 ( 0.01%)     3 ( 0.03%)  76,228 ( 0.57%)      1 ( 0.00%)      1 ( 0.00%)  ???:std::basic_filebuf<char, std::char_traits<char> >::xsputn(char const*, long)
  651,185 ( 1.31%)  20 ( 0.63%)  20 ( 0.75%) 189,088 ( 1.07%)  5,747 ( 3.29%)     2 ( 0.02%) 105,229 ( 0.78%)    258 ( 0.17%)      1 ( 0.00%)  ./malloc/malloc.c:_int_free
  620,658 ( 1.25%)   3 ( 0.09%)   3 ( 0.11%) 151,380 ( 0.86%)      0              0          227,070 ( 1.69%)      0               0           /usr/include/c++/10/bits/alloc_traits.h:void std::allocator_traits<std::allocator<sim::Particle> >::construct<sim::Particle, unsigned long, sim::vec3&, sim::vec3&, sim::vec3&>(std::allocator<sim::Particle>&, sim::Particle*, unsigned long&&, sim::vec3&, sim::vec3&, sim::vec3&)
  620,658 ( 1.25%)   2 ( 0.06%)   2 ( 0.07%)  90,828 ( 0.51%)      0              0          317,898 ( 2.36%) 26,492 (17.65%) 26,491 (26.40%)  /usr/include/c++/10/bits/stl_construct.h:void std::_Construct<sim::Particle>(sim::Particle*)
  592,176 ( 1.19%)  52 ( 1.63%)  42 ( 1.57%) 188,950 ( 1.07%)  4,425 ( 2.53%)   867 ( 8.87%)  95,015 ( 0.71%)    100 ( 0.07%)     44 ( 0.04%)  ./elf/dl-lookup.c:do_lookup_x
  575,244 ( 1.16%)   2 ( 0.06%)   2 ( 0.07%) 348,174 ( 1.97%) 15,138 ( 8.66%)    13 ( 0.13%) 196,794 ( 1.46%) 29,886 (19.91%)      0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/particle.cpp:sim::Particle::operator=(sim::Particle const&)
  552,580 ( 1.11%)   0            0          236,820 ( 1.34%)      0              0          236,820 ( 1.76%)      0               0           /usr/include/c++/10/new:operator new(unsigned long, void*)
  543,857 ( 1.10%)   6 ( 0.19%)   3 ( 0.11%) 228,299 ( 1.29%)      0              0          137,476 ( 1.02%)      0               0           /usr/include/c++/10/bits/stl_uninitialized.h:sim::Particle* std::__uninitialized_copy<false>::__uninit_copy<sim::Particle const*, sim::Particle*>(sim::Particle const*, sim::Particle const*, sim::Particle*)
  514,838 ( 1.04%)  14 ( 0.44%)  13 ( 0.49%)  75,746 ( 0.43%)      2 ( 0.00%)     1 ( 0.01%) 121,131 ( 0.90%)      2 ( 0.00%)      0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/grid.cpp:sim::Grid::Grid(int, double, std::vector<sim::Particle, std::allocator<sim::Particle> >&)
  512,533 ( 1.03%)   3 ( 0.09%)   3 ( 0.11%) 135,672 ( 0.77%)      1 ( 0.00%)     0           90,445 ( 0.67%)      0               0           ???:std::basic_streambuf<char, std::char_traits<char> >::xsputn(char const*, long)
  502,155 ( 1.01%)   2 ( 0.06%)   1 ( 0.04%) 200,862 ( 1.14%)    769 ( 0.44%)     0           66,954 ( 0.50%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::size() const
  500,669 ( 1.01%)   3 ( 0.09%)   2 ( 0.07%) 154,052 ( 0.87%)      0              0          115,539 ( 0.86%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::end()
  500,067 ( 1.01%)   0            0          129,647 ( 0.73%)      0              0          166,689 ( 1.24%)      0               0           /usr/include/c++/10/bits/stl_construct.h:void std::_Construct<sim::Particle, sim::Particle const&>(sim::Particle*, sim::Particle const&)
  499,554 ( 1.01%)   0            0          272,484 ( 1.54%)      0              0          136,242 ( 1.01%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >::operator++()
  494,551 ( 1.00%)  91 ( 2.85%)  52 ( 1.94%)  80,318 ( 0.46%)  1,205 ( 0.69%)     0           82,886 ( 0.62%)  3,038 ( 2.02%)  2,326 ( 2.32%)  ./malloc/malloc.c:_int_malloc
  484,480 ( 0.98%)   2 ( 0.06%)   2 ( 0.07%) 166,540 ( 0.94%)      2 ( 0.00%)     0          105,980 ( 0.79%)      0               0           ???:std::ostream::write(char const*, long)
  426,819 ( 0.86%)   4 ( 0.13%)   4 ( 0.15%) 117,166 ( 0.66%)      0              0          117,166 ( 0.87%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::_M_check_len(unsigned long, char const*) const
  423,864 ( 0.85%)   1 ( 0.03%)   1 ( 0.04%) 242,208 ( 1.37%)      0              0          121,104 ( 0.90%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >::operator*() const
  423,864 ( 0.85%)   1 ( 0.03%)   1 ( 0.04%) 105,966 ( 0.60%)      0              0          136,242 ( 1.01%)      0               0           /usr/include/c++/10/bits/stl_construct.h:decltype (::new ((void*)(0)) sim::Particle((declval<sim::Particle const&>)())) std::construct_at<sim::Particle, sim::Particle const&>(sim::Particle*, sim::Particle const&)
  418,450 ( 0.84%)   1 ( 0.03%)   1 ( 0.04%) 117,166 ( 0.66%)      0              0          150,642 ( 1.12%)      0               0           /usr/include/c++/10/bits/stl_uninitialized.h:sim::Particle* std::__uninitialized_move_if_noexcept_a<sim::Particle*, sim::Particle*, std::allocator<sim::Particle> >(sim::Particle*, sim::Particle*, sim::Particle*, std::allocator<sim::Particle>&)
  405,243 ( 0.82%)   2 ( 0.06%)   1 ( 0.04%) 150,090 ( 0.85%)  1,877 ( 1.07%)     0           60,036 ( 0.45%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::~_Vector_base()
  375,250 ( 0.76%)   3 ( 0.09%)   2 ( 0.07%) 163,318 ( 0.93%) 11,865 ( 6.79%)     0           75,690 ( 0.56%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::push_back(sim::Particle const&)
  350,685 ( 0.71%)   4 ( 0.13%)   2 ( 0.07%)  93,516 ( 0.53%)      0              0          116,895 ( 0.87%)      0               0           /usr/include/c++/10/bits/stl_construct.h:void std::_Destroy<sim::Particle*>(sim::Particle*, sim::Particle*)
  349,950 ( 0.71%)  15 ( 0.47%)   7 ( 0.26%)  99,907 ( 0.57%)    840 ( 0.48%)     0           44,712 ( 0.33%)      0               0           ./malloc/malloc.c:malloc
  348,174 ( 0.70%)   2 ( 0.06%)   2 ( 0.07%)  90,828 ( 0.51%)      0              0           90,828 ( 0.67%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/../sim/grid/particle.hpp:sim::Particle::Particle()
  348,174 ( 0.70%)   1 ( 0.03%)   1 ( 0.04%)  90,828 ( 0.51%)      0              0           75,690 ( 0.56%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >::operator-(long) const
  342,996 ( 0.69%)   0            0          171,498 ( 0.97%)      0              0          114,332 ( 0.85%)      0               0           /usr/include/c++/10/bits/move.h:sim::Particle const& std::forward<sim::Particle const&>(std::remove_reference<sim::Particle const&>::type&)
  327,306 ( 0.66%)   1 ( 0.03%)   1 ( 0.04%)  93,516 ( 0.53%)      0              0          116,895 ( 0.87%)      1 ( 0.00%)      0           /usr/include/c++/10/bits/alloc_traits.h:void std::_Destroy<sim::Particle*, sim::Particle>(sim::Particle*, sim::Particle*, std::allocator<sim::Particle>&)
  318,549 ( 0.64%)   4 ( 0.13%)   3 ( 0.11%) 106,183 ( 0.60%)     11 ( 0.01%)     3 ( 0.03%)  75,845 ( 0.56%)      0               0           ???:std::ostream::sentry::sentry(std::ostream&)
  315,189 ( 0.64%)   3 ( 0.09%)   2 ( 0.07%) 120,072 ( 0.68%)  3,752 ( 2.15%)     0           75,045 ( 0.56%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::~vector()
  307,395 ( 0.62%)   1 ( 0.03%)   0           95,250 ( 0.54%)      0              0          101,887 ( 0.76%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_M_deallocate(sim::Particle*, unsigned long)
  301,320 ( 0.61%)   2 ( 0.06%)   2 ( 0.07%)  66,960 ( 0.38%)      0              0          100,440 ( 0.75%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::_S_max_size(std::allocator<sim::Particle> const&)
  285,095 ( 0.57%)   1 ( 0.03%)   1 ( 0.04%) 105,035 ( 0.60%)      0              0           90,030 ( 0.67%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:bool __gnu_cxx::operator==<sim::Block*, sim::Block*, std::vector<sim::Block, std::allocator<sim::Block> > >(__gnu_cxx::__normal_iterator<sim::Block*, std::vector<sim::Block, std::allocator<sim::Block> > > const&, __gnu_cxx::__normal_iterator<sim::Block*, std::vector<sim::Block, std::allocator<sim::Block> > > const&)
  280,500 ( 0.57%)   1 ( 0.03%)   0           93,500 ( 0.53%)      0              0           70,125 ( 0.52%)      1 ( 0.00%)      1 ( 0.00%)  /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::begin()
  272,484 ( 0.55%)   2 ( 0.06%)   2 ( 0.07%)  45,414 ( 0.26%)      0              0          105,966 ( 0.79%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::back()
  272,484 ( 0.55%)   0            0          136,242 ( 0.77%)      0              0           90,828 ( 0.67%)      0               0           /usr/include/c++/10/bits/move.h:unsigned long&& std::forward<unsigned long>(std::remove_reference<unsigned long>::type&)
  265,470 ( 0.54%)  25 ( 0.78%)  25 ( 0.93%)  58,447 ( 0.33%)  2,874 ( 1.64%) 2,398 (24.52%)  21,569 ( 0.16%)  1,667 ( 1.11%)    913 ( 0.91%)  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
  257,346 ( 0.52%)   0            0           60,552 ( 0.34%)      0              0           90,828 ( 0.67%)      0               0           /usr/include/c++/10/bits/alloc_traits.h:void std::allocator_traits<std::allocator<sim::Particle> >::construct<sim::Particle, sim::Particle const&>(std::allocator<sim::Particle>&, sim::Particle*, sim::Particle const&)
  251,085 ( 0.51%)   2 ( 0.06%)   1 ( 0.04%)  83,695 ( 0.47%)      0              0          100,434 ( 0.75%)      0               0           /usr/include/c++/10/bits/stl_uninitialized.h:sim::Particle* std::uninitialized_copy<sim::Particle const*, sim::Particle*>(sim::Particle const*, sim::Particle const*, sim::Particle*)
  251,085 ( 0.51%)   0            0           83,695 ( 0.47%)      0              0          100,434 ( 0.75%)      0               0           /usr/include/c++/10/bits/stl_uninitialized.h:sim::Particle* std::__uninitialized_copy_a<sim::Particle const*, sim::Particle*, sim::Particle>(sim::Particle const*, sim::Particle const*, sim::Particle*, std::allocator<sim::Particle>&)
  240,726 ( 0.49%)   1 ( 0.03%)   1 ( 0.04%) 120,363 ( 0.68%)      0              0           80,242 ( 0.60%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_M_get_Tp_allocator()
  240,064 ( 0.48%)   1 ( 0.03%)   1 ( 0.04%)  45,012 ( 0.26%)      0              0          105,028 ( 0.78%)  5,627 ( 3.75%)  5,626 ( 5.61%)  /usr/include/c++/10/bits/stl_construct.h:void std::_Construct<sim::Block>(sim::Block*)
  217,659 ( 0.44%)   3 ( 0.09%)   2 ( 0.07%) 117,201 ( 0.66%)      0              0           50,229 ( 0.37%)      0               0           /usr/include/c++/10/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&)
  211,932 ( 0.43%)   1 ( 0.03%)   1 ( 0.04%)  75,690 ( 0.43%)      0              0           45,414 ( 0.34%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::operator[](unsigned long)
  211,932 ( 0.43%)   0            0           75,690 ( 0.43%)      0              0           45,414 ( 0.34%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Block, std::allocator<sim::Block> >::operator[](unsigned long)
  201,954 ( 0.41%)   1 ( 0.03%)   1 ( 0.04%) 100,977 ( 0.57%)      0              0           67,318 ( 0.50%)      0               0           /usr/include/c++/10/bits/move.h:sim::Particle* std::__addressof<sim::Particle>(sim::Particle&)
  200,868 ( 0.41%)   1 ( 0.03%)   1 ( 0.04%) 100,434 ( 0.57%)      0              0           66,956 ( 0.50%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:sim::Particle const* std::__make_move_if_noexcept_iterator<sim::Particle, sim::Particle const*>(sim::Particle*)
  200,665 ( 0.40%)   1 ( 0.03%)   1 ( 0.04%)  80,266 ( 0.45%)      0              0           40,133 ( 0.30%)      0               0           /usr/include/c++/10/type_traits:std::is_constant_evaluated()
  196,794 ( 0.40%)   1 ( 0.03%)   1 ( 0.04%)  60,552 ( 0.34%)      0              0           60,552 ( 0.45%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/block.cpp:sim::Block::AddParticle(sim::Particle&)
  195,078 ( 0.39%)   2 ( 0.06%)   2 ( 0.07%)  60,024 ( 0.34%)      0              0           60,024 ( 0.45%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_Vector_impl::_Vector_impl()
  192,533 ( 0.39%)   2 ( 0.06%)   1 ( 0.04%)  41,855 ( 0.24%)      0              0           50,226 ( 0.37%)      0               0           /usr/include/c++/10/ext/new_allocator.h:__gnu_cxx::new_allocator<sim::Particle>::allocate(unsigned long, void const*)
  192,487 ( 0.39%)   2 ( 0.06%)   2 ( 0.07%)  58,583 ( 0.33%)      0              0           50,214 ( 0.37%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >::difference_type __gnu_cxx::operator-<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > >(__gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > > const&, __gnu_cxx::__normal_iterator<sim::Particle*, std::vector<sim::Particle, std::allocator<sim::Particle> > > const&)
  184,129 ( 0.37%)   2 ( 0.06%)   1 ( 0.04%)  50,217 ( 0.28%)      0              0           66,956 ( 0.50%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::max_size() const
  181,668 ( 0.37%)   1 ( 0.03%)   1 ( 0.04%)  90,834 ( 0.51%)      0              0           30,278 ( 0.22%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<float, std::allocator<float> >::size() const
  180,120 ( 0.36%)   1 ( 0.03%)   1 ( 0.04%)  75,050 ( 0.43%)      0              0           75,050 ( 0.56%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_Vector_impl_data::_Vector_impl_data()
  180,060 ( 0.36%)   0            0           90,030 ( 0.51%)      0              0           60,020 ( 0.45%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Block*, std::vector<sim::Block, std::allocator<sim::Block> > >::base() const
  180,048 ( 0.36%)   0            0           90,024 ( 0.51%)      0              0           60,016 ( 0.45%)      0               0           /usr/include/c++/10/bits/move.h:sim::Block* std::__addressof<sim::Block>(sim::Block&)
  167,580 ( 0.34%)   8 ( 0.25%)   4 ( 0.15%)  41,894 ( 0.24%)  3,383 ( 1.94%)     2 ( 0.02%)       4 ( 0.00%)      0               0           ./malloc/malloc.c:free
  167,436 ( 0.34%) 328 (10.28%) 270 (10.09%) 165,639 ( 0.94%)    543 ( 0.31%)    29 ( 0.30%)     874 ( 0.01%)     24 ( 0.02%)     14 ( 0.01%)  ???:???
  166,540 ( 0.34%)  14 ( 0.44%)   4 ( 0.15%)  45,378 ( 0.26%)      2 ( 0.00%)     1 ( 0.01%)  30,248 ( 0.22%)  4,395 ( 2.93%)    130 ( 0.13%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  165,044 ( 0.33%)   0            0           90,024 ( 0.51%)      0              0           45,012 ( 0.33%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Block*, std::vector<sim::Block, std::allocator<sim::Block> > >::operator++()
  163,653 ( 0.33%)   0            0           46,758 ( 0.27%)      0              0           70,137 ( 0.52%)      0               0           /usr/include/c++/10/bits/stl_construct.h:void std::_Destroy_aux<true>::__destroy<sim::Particle*>(sim::Particle*, sim::Particle*)
  151,395 ( 0.31%)   2 ( 0.06%)   2 ( 0.07%)  60,558 ( 0.34%)      0              0           30,281 ( 0.22%)      0               0           /usr/include/c++/10/bits/stl_uninitialized.h:sim::Particle* std::__uninitialized_default_n_1<false>::__uninit_default_n<sim::Particle*, unsigned long>(sim::Particle*, unsigned long)
  150,678 ( 0.30%)   0            0           33,484 ( 0.19%)      0              0           41,855 ( 0.31%)      1 ( 0.00%)      0           /usr/include/c++/10/ext/new_allocator.h:__gnu_cxx::new_allocator<sim::Particle>::deallocate(sim::Particle*, unsigned long)
  150,090 ( 0.30%)   3 ( 0.09%)   0           45,027 ( 0.26%)      0              0           45,027 ( 0.33%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_Vector_impl::~_Vector_impl()
  150,070 ( 0.30%)   3 ( 0.09%)   2 ( 0.07%)  45,021 ( 0.26%)      0              0           45,021 ( 0.33%)      0               0           /usr/include/c++/10/bits/allocator.h:std::allocator<sim::Particle>::allocator()
  150,060 ( 0.30%)   1 ( 0.03%)   1 ( 0.04%)  45,018 ( 0.26%)      0              0           45,018 ( 0.33%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::vector<sim::Particle, std::allocator<sim::Particle> >::vector()
  150,060 ( 0.30%)   0            0           45,018 ( 0.26%)      0              0           45,018 ( 0.33%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_Vector_base()
  150,052 ( 0.30%)   1 ( 0.03%)   1 ( 0.04%)  60,021 ( 0.34%)      0              0           30,012 ( 0.22%)      0               0           /usr/include/c++/10/bits/stl_uninitialized.h:sim::Block* std::__uninitialized_default_n_1<false>::__uninit_default_n<sim::Block*, unsigned long>(sim::Block*, unsigned long)
  150,051 ( 0.30%)   1 ( 0.03%)   1 ( 0.04%)  60,020 ( 0.34%)      1 ( 0.00%)     0           30,011 ( 0.22%)      0               0           /usr/include/c++/10/bits/stl_construct.h:void std::_Destroy_aux<false>::__destroy<sim::Block*>(sim::Block*, sim::Block*)
  150,040 ( 0.30%)   2 ( 0.06%)   2 ( 0.07%)  45,012 ( 0.26%)      0              0           45,012 ( 0.33%)      0               0           /usr/include/c++/10/bits/stl_construct.h:void std::destroy_at<sim::Block>(sim::Block*)
  150,040 ( 0.30%)   0            0           45,012 ( 0.26%)      0              0           45,012 ( 0.33%)      0               0           /usr/include/c++/10/bits/stl_construct.h:void std::_Destroy<sim::Block>(sim::Block*)
  150,040 ( 0.30%)   0            0           45,012 ( 0.26%)      0              0           45,012 ( 0.33%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/block.hpp:sim::Block::Block()
  150,040 ( 0.30%)   0            0           45,012 ( 0.26%)      0              0           45,012 ( 0.33%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/block.hpp:sim::Block::~Block()
  136,242 ( 0.27%)   0            0           45,414 ( 0.26%)      0              0           45,414 ( 0.34%)      0               0           /usr/include/c++/10/array:std::array<float, 9ul>::data()
  133,936 ( 0.27%)   2 ( 0.06%)   1 ( 0.04%)  41,855 ( 0.24%)      0              0           58,597 ( 0.44%)      1 ( 0.00%)      0           /usr/include/c++/10/bits/alloc_traits.h:std::allocator_traits<std::allocator<sim::Particle> >::deallocate(std::allocator<sim::Particle>&, sim::Particle*, unsigned long)
  125,565 ( 0.25%)   2 ( 0.06%)   1 ( 0.04%)  41,855 ( 0.24%)      0              0           33,484 ( 0.25%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_M_allocate(unsigned long)
  121,468 ( 0.24%)   6 ( 0.19%)   6 ( 0.22%)  40,487 ( 0.23%)    454 ( 0.26%)   237 ( 2.42%)  13,535 ( 0.10%)     26 ( 0.02%)      8 ( 0.01%)  ./elf/dl-lookup.c:check_match
  110,824 ( 0.22%)   1 ( 0.03%)   0           58,583 ( 0.33%)      0              0           25,107 ( 0.19%)      0               0           /usr/include/c++/10/bits/stl_algobase.h:unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&)
  105,028 ( 0.21%)   0            0           60,016 ( 0.34%)      0              0           30,008 ( 0.22%)      0               0           /usr/include/c++/10/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<sim::Block*, std::vector<sim::Block, std::allocator<sim::Block> > >::operator*() const
  100,440 ( 0.20%)   2 ( 0.06%)   2 ( 0.07%)  50,220 ( 0.28%)      0              0           33,480 ( 0.25%)      0               0           /usr/include/c++/10/bits/stl_vector.h:std::_Vector_base<sim::Particle, std::allocator<sim::Particle> >::_M_get_Tp_allocator() const
  100,440 ( 0.20%)   0            0           33,480 ( 0.19%)      0              0           33,480 ( 0.25%)      0               0           /usr/include/c++/10/bits/alloc_traits.h:std::allocator_traits<std::allocator<sim::Particle> >::max_size(std::allocator<sim::Particle> const&)
   92,081 ( 0.19%)   2 ( 0.06%)   1 ( 0.04%)  33,484 ( 0.19%)      0              0           41,855 ( 0.31%)      0               0           /usr/include/c++/10/bits/alloc_traits.h:std::allocator_traits<std::allocator<sim::Particle> >::allocate(std::allocator<sim::Particle>&, unsigned long)
   91,014 ( 0.18%)   9 ( 0.28%)   1 ( 0.04%)  75,845 ( 0.43%)      0              0                0               0               0           ???:std::ostream::sentry::~sentry()
   90,834 ( 0.18%)   2 ( 0.06%)   1 ( 0.04%)  45,417 ( 0.26%)      0              0                0               0               0           ./math/../sysdeps/x86_64/fpu/multiarch/s_floor-sse4_1.S:__floor_sse41
   90,828 ( 0.18%)   0            0           45,414 ( 0.26%)      0              0           30,276 ( 0.22%)      0               0           /usr/include/c++/10/array:std::__array_traits<float, 9ul>::_S_ptr(float const (&) [9])
   90,315 ( 0.18%)  14 ( 0.44%)  14 ( 0.52%)  30,555 ( 0.17%)  2,759 ( 1.58%) 1,786 (18.26%)   6,837 ( 0.05%)      4 ( 0.00%)      0           ./elf/do-rel.h:_dl_relocate_object
   90,072 ( 0.18%)   0            0           30,024 ( 0.17%)      0              0           30,024 ( 0.22%)      0               0           /usr/include/c++/10/bits/allocator.h:std::allocator<sim::Particle>::~allocator()
   90,042 ( 0.18%)   3 ( 0.09%)   2 ( 0.07%)  30,014 ( 0.17%)      0              0           30,014 ( 0.22%)      0               0           /usr/include/c++/10/ext/new_allocator.h:__gnu_cxx::new_allocator<sim::Particle>::new_allocator()
   90,024 ( 0.18%)   1 ( 0.03%)   1 ( 0.04%)  45,012 ( 0.26%)      0              0           30,008 ( 0.22%)      0               0           /home/alumnos/a0432481/ArquiCompP1/sim/grid/block.cpp:sim::Block::GetParticles()
   83,760 ( 0.17%)   2 ( 0.06%)   1 ( 0.04%)  16,752 ( 0.09%)      0              0           16,752 ( 0.12%)      0               0           ???:operator new(unsigned long)
   83,710 ( 0.17%)   2 ( 0.06%)   1 ( 0.04%)  16,742 ( 0.09%)      0              0           16,742 ( 0.12%)      0               0           /usr/include/c++/10/bits/allocator.h:std::allocator_traits<std::allocator<sim::Particle> >::allocate(std::allocator<sim::Particle>&, unsigned long)
   78,360 ( 0.16%) 171 ( 5.36%)  77 ( 2.88%)  19,339 ( 0.11%)    278 ( 0.16%)   109 ( 1.11%)       0               0               0           ./string/../sysdeps/x86_64/strcmp.S:strcmp
   75,339 ( 0.15%)   0            0           25,113 ( 0.14%)      0              0           16,742 ( 0.12%)      0               0           /usr/include/c++/10/bits/allocator.h:std::allocator_traits<std::allocator<sim::Particle> >::deallocate(std::allocator<sim::Particle>&, sim::Particle*, unsigned long)
   71,545 ( 0.14%)  11 ( 0.34%)  11 ( 0.41%)  14,316 ( 0.08%)  1,096 ( 0.63%)   922 ( 9.43%)      17 ( 0.00%)      1 ( 0.00%)      0           ./elf/dl-addr.c:_dl_addr
   56,002 ( 0.11%)   4 ( 0.13%)   4 ( 0.15%)  21,573 ( 0.12%)  3,887 ( 2.22%)     0            5,738 ( 0.04%)      0               0           ./malloc/malloc.c:unlink_chunk.constprop.0
   50,226 ( 0.10%)   4 ( 0.13%)   2 ( 0.07%)  16,742 ( 0.09%)      0              0           16,742 ( 0.12%)      0               0           /usr/include/c++/10/ext/new_allocator.h:__gnu_cxx::new_allocator<sim::Particle>::_M_max_size() const

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_iterator.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr           DLmr           Dw               D1mw       DLmw       

-- line 970 ----------------------------------------
      .          .          .                .              .              .                .          .          .           #if __cplusplus > 201703L && __cpp_lib_concepts
      .          .          .                .              .              .                .          .          .                 using iterator_concept = std::__detail::__iter_concept<_Iterator>;
      .          .          .                .              .              .                .          .          .           #endif
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .                 : _M_current(_Iterator()) { }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 explicit _GLIBCXX20_CONSTEXPR
308,120 ( 0.62%) 1 ( 0.03%) 0                0              0              0          231,090 ( 1.72%) 0          0                 __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
539,210 ( 1.09%) 0          0          385,150 ( 2.18%) 5,629 ( 3.22%) 1,017 (10.40%)  77,030 ( 0.57%) 0          0                 : _M_current(__i) { }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 // Allow iterator to const_iterator conversion
      .          .          .                .              .              .                .          .          .                 template<typename _Iter>
      .          .          .                .              .              .                .          .          .                   _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                   __normal_iterator(const __normal_iterator<_Iter,
      .          .          .                .              .              .                .          .          .           			  typename __enable_if<
      .          .          .                .              .              .                .          .          .                 	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
      .          .          .                .              .              .                .          .          .           		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .                   : _M_current(__i.base()) { }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 // Forward iterator requirements
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 reference
226,668 ( 0.46%) 1 ( 0.03%) 1 ( 0.04%)       0              0              0          151,112 ( 1.12%) 0          0                 operator*() const _GLIBCXX_NOEXCEPT
302,224 ( 0.61%) 0          0          302,224 ( 1.71%)     0              0                0          0          0                 { return *_M_current; }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 pointer
      .          .          .                .              .              .                .          .          .                 operator->() const _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .                 { return _M_current; }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 __normal_iterator&
181,254 ( 0.37%) 0          0                0              0              0          120,836 ( 0.90%) 0          0                 operator++() _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .                 {
302,090 ( 0.61%) 0          0          181,254 ( 1.03%)     0              0           60,418 ( 0.45%) 0          0           	++_M_current;
 60,418 ( 0.12%) 0          0           60,418 ( 0.34%)     0              0                0          0          0           	return *this;
120,836 ( 0.24%) 0          0          120,836 ( 0.68%)     0              0                0          0          0                 }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 __normal_iterator
      .          .          .                .              .              .                .          .          .                 operator++(int) _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .                 { return __normal_iterator(_M_current++); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 // Bidirectional iterator requirements
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
-- line 1015 ----------------------------------------
-- line 1043 ----------------------------------------
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 __normal_iterator&
      .          .          .                .              .              .                .          .          .                 operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .                 { _M_current -= __n; return *this; }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 __normal_iterator
 75,690 ( 0.15%) 1 ( 0.03%) 1 ( 0.04%)       0              0              0           45,414 ( 0.34%) 0          0                 operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
272,484 ( 0.55%) 0          0           90,828 ( 0.51%)     0              0           30,276 ( 0.22%) 0          0                 { return __normal_iterator(_M_current - __n); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .                 _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .                 const _Iterator&
552,990 ( 1.12%) 1 ( 0.03%) 1 ( 0.04%)       0              0              0          368,660 ( 2.74%) 0          0                 base() const _GLIBCXX_NOEXCEPT
552,990 ( 1.12%) 0          0          552,990 ( 3.13%)     0              0                0          0          0                 { return _M_current; }
      .          .          .                .              .              .                .          .          .               };
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             // Note: In what follows, the left- and right-hand-side iterators are
      .          .          .                .              .              .                .          .          .             // allowed to vary in types (conceptually in cv-qualification) so that
      .          .          .                .              .              .                .          .          .             // comparison between cv-qualified and non-cv-qualified iterators be
      .          .          .                .              .              .                .          .          .             // valid.  However, the greedy and unfriendly operators in std::rel_ops
      .          .          .                .              .              .                .          .          .             // will make overload resolution ambiguous (when in scope) if we don't
      .          .          .                .              .              .                .          .          .             // provide overloads whose operands are of the same type.  Can someone
      .          .          .                .              .              .                .          .          .             // remind me what generic programming is about? -- Gaby
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .           #if __cpp_lib_three_way_comparison
      .          .          .                .              .              .                .          .          .             template<typename _IteratorL, typename _IteratorR, typename _Container>
      .          .          .                .              .              .                .          .          .               requires requires (_IteratorL __lhs, _IteratorR __rhs)
      .          .          .                .              .              .                .          .          .               { { __lhs == __rhs } -> std::convertible_to<bool>; }
      .          .          .                .              .              .                .          .          .               constexpr bool
452,550 ( 0.91%) 2 ( 0.06%) 2 ( 0.07%)       0              0              0          301,700 ( 2.24%) 0          0               operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .          .          .                .              .              .                .          .          .           	       const __normal_iterator<_IteratorR, _Container>& __rhs)
      .          .          .                .              .              .                .          .          .               noexcept(noexcept(__lhs.base() == __rhs.base()))
980,525 ( 1.98%) 1 ( 0.03%) 0          527,975 ( 2.99%)     0              0          150,850 ( 1.12%) 0          0               { return __lhs.base() == __rhs.base(); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             template<typename _IteratorL, typename _IteratorR, typename _Container>
      .          .          .                .              .              .                .          .          .               constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
      .          .          .                .              .              .                .          .          .               operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .          .          .                .              .              .                .          .          .           		const __normal_iterator<_IteratorR, _Container>& __rhs)
      .          .          .                .              .              .                .          .          .               noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
      .          .          .                .              .              .                .          .          .               { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
      .          .          .                .              .              .                .          .          .           #else
-- line 1084 ----------------------------------------
-- line 1194 ----------------------------------------
      .          .          .                .              .              .                .          .          .               operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .          .          .                .              .              .                .          .          .           	      const __normal_iterator<_IteratorR, _Container>& __rhs)
      .          .          .                .              .              .                .          .          .           #endif
      .          .          .                .              .              .                .          .          .               { return __lhs.base() - __rhs.base(); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             template<typename _Iterator, typename _Container>
      .          .          .                .              .              .                .          .          .               _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .               inline typename __normal_iterator<_Iterator, _Container>::difference_type
 50,220 ( 0.10%) 2 ( 0.06%) 2 ( 0.07%)       0              0              0           33,480 ( 0.25%) 0          0               operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
      .          .          .                .              .              .                .          .          .           	      const __normal_iterator<_Iterator, _Container>& __rhs)
      .          .          .                .              .              .                .          .          .               _GLIBCXX_NOEXCEPT
142,287 ( 0.29%) 1 ( 0.03%) 1 ( 0.04%)  58,590 ( 0.33%)     0              0           16,740 ( 0.12%) 0          0               { return __lhs.base() - __rhs.base(); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             template<typename _Iterator, typename _Container>
      .          .          .                .              .              .                .          .          .               _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .               inline __normal_iterator<_Iterator, _Container>
      .          .          .                .              .              .                .          .          .               operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
      .          .          .                .              .              .                .          .          .           	      __n, const __normal_iterator<_Iterator, _Container>& __i)
      .          .          .                .              .              .                .          .          .               _GLIBCXX_NOEXCEPT
      .          .          .                .              .              .                .          .          .               { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
-- line 1213 ----------------------------------------
-- line 1217 ----------------------------------------
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .           namespace std _GLIBCXX_VISIBILITY(default)
      .          .          .                .              .              .                .          .          .           {
      .          .          .                .              .              .                .          .          .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             template<typename _Iterator, typename _Container>
      .          .          .                .              .              .                .          .          .               _GLIBCXX20_CONSTEXPR
      .          .          .                .              .              .                .          .          .               _Iterator
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0              0              0                4 ( 0.00%) 0          0               __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
      .          .          .                .              .              .                .          .          .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
     12 ( 0.00%) 0          0                6 ( 0.00%)     0              0                2 ( 0.00%) 0          0               { return __it.base(); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .              .              .                .          .          .             /**
      .          .          .                .              .              .                .          .          .              * @addtogroup iterators
      .          .          .                .              .              .                .          .          .              * @{
      .          .          .                .              .              .                .          .          .              */
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .           #if __cplusplus > 201703L && __cpp_lib_concepts
-- line 1235 ----------------------------------------
-- line 1588 ----------------------------------------
      .          .          .                .              .              .                .          .          .               { return _ReturnType(__i); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             // Overload for pointers that matches std::move_if_noexcept more closely,
      .          .          .                .              .              .                .          .          .             // returning a constant iterator when we don't want to move.
      .          .          .                .              .              .                .          .          .             template<typename _Tp, typename _ReturnType
      .          .          .                .              .              .                .          .          .               = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      .          .          .                .              .              .                .          .          .           			   const _Tp*, move_iterator<_Tp*>>::type>
      .          .          .                .              .              .                .          .          .               inline _GLIBCXX17_CONSTEXPR _ReturnType
100,434 ( 0.20%) 1 ( 0.03%) 1 ( 0.04%)       0              0              0           66,956 ( 0.50%) 0          0               __make_move_if_noexcept_iterator(_Tp* __i)
100,434 ( 0.20%) 0          0          100,434 ( 0.57%)     0              0                0          0          0               { return _ReturnType(__i); }
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .           #if __cplusplus > 201703L && __cpp_lib_concepts
      .          .          .                .              .              .                .          .          .             // [iterators.common] Common iterators
      .          .          .                .              .              .                .          .          .           
      .          .          .                .              .              .                .          .          .             namespace __detail
      .          .          .                .              .              .                .          .          .             {
      .          .          .                .              .              .                .          .          .               template<typename _It>
      .          .          .                .              .              .                .          .          .                 concept __common_iter_has_arrow = indirectly_readable<const _It>
-- line 1605 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_uninitialized.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 76 ----------------------------------------
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /// @cond undocumented
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<bool _TrivialValueTypes>
      .          .          .                .          .          .                .          .          .               struct __uninitialized_copy
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 template<typename _InputIterator, typename _ForwardIterator>
      .          .          .                .          .          .                .          .          .                   static _ForwardIterator
117,173 ( 0.24%) 2 ( 0.06%) 1 ( 0.04%)       0          0          0           83,695 ( 0.62%) 0          0                   __uninit_copy(_InputIterator __first, _InputIterator __last,
      .          .          .                .          .          .                .          .          .           		      _ForwardIterator __result)
      .          .          .                .          .          .                .          .          .                   {
 33,478 ( 0.07%) 0          0           16,739 ( 0.09%) 0          0           16,739 ( 0.12%) 0          0           	  _ForwardIterator __cur = __result;
      .          .          .                .          .          .                .          .          .           	  __try
      .          .          .                .          .          .                .          .          .           	    {
161,343 ( 0.33%) 0          0          107,562 ( 0.61%) 0          0                0          0          0           	      for (; __first != __last; ++__first, (void)++__cur)
148,168 ( 0.30%) 0          0           37,042 ( 0.21%) 0          0           37,042 ( 0.28%) 0          0           		std::_Construct(std::__addressof(*__cur), *__first);
 33,478 ( 0.07%) 2 ( 0.06%) 1 ( 0.04%)  16,739 ( 0.09%) 0          0                0          0          0           	      return __cur;
      .          .          .                .          .          .                .          .          .           	    }
      .          .          .                .          .          .                .          .          .           	  __catch(...)
      .          .          .                .          .          .                .          .          .           	    {
      .          .          .                .          .          .                .          .          .           	      std::_Destroy(__result, __cur);
      .          .          .                .          .          .                .          .          .           	      __throw_exception_again;
      .          .          .                .          .          .                .          .          .           	    }
 50,217 ( 0.10%) 2 ( 0.06%) 1 ( 0.04%)  50,217 ( 0.28%) 0          0                0          0          0           	}
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<>
      .          .          .                .          .          .                .          .          .               struct __uninitialized_copy<true>
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 template<typename _InputIterator, typename _ForwardIterator>
      .          .          .                .          .          .                .          .          .                   static _ForwardIterator
      6 ( 0.00%) 0          0                0          0          0                4 ( 0.00%) 0          0                   __uninit_copy(_InputIterator __first, _InputIterator __last,
      .          .          .                .          .          .                .          .          .           		      _ForwardIterator __result)
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       5 ( 0.00%) 0          0                1 ( 0.00%) 0          0                   { return std::copy(__first, __last, __result); }
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /// @endcond
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /**
      .          .          .                .          .          .                .          .          .              *  @brief Copies the range [first,last) into result.
      .          .          .                .          .          .                .          .          .              *  @param  __first  An input iterator.
      .          .          .                .          .          .                .          .          .              *  @param  __last   An input iterator.
      .          .          .                .          .          .                .          .          .              *  @param  __result An output iterator.
      .          .          .                .          .          .                .          .          .              *  @return   __result + (__first - __last)
      .          .          .                .          .          .                .          .          .              *
      .          .          .                .          .          .                .          .          .              *  Like copy(), but does not require an initialized output range.
      .          .          .                .          .          .                .          .          .             */
      .          .          .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator>
      .          .          .                .          .          .                .          .          .               inline _ForwardIterator
100,440 ( 0.20%) 2 ( 0.06%) 1 ( 0.04%)       0          0          0           66,960 ( 0.50%) 0          0               uninitialized_copy(_InputIterator __first, _InputIterator __last,
      .          .          .                .          .          .                .          .          .           		       _ForwardIterator __result)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 typedef typename iterator_traits<_InputIterator>::value_type
      .          .          .                .          .          .                .          .          .           	_ValueType1;
      .          .          .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .          .          .                .          .          .                .          .          .           	_ValueType2;
      .          .          .                .          .          .                .          .          .           #if __cplusplus < 201103L
      .          .          .                .          .          .                .          .          .                 const bool __assignable = true;
-- line 133 ----------------------------------------
-- line 136 ----------------------------------------
      .          .          .                .          .          .                .          .          .                 // optimization that uses memmove would happily "copy" them anyway.
      .          .          .                .          .          .                .          .          .                 static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
      .          .          .                .          .          .                .          .          .           	  "result type must be constructible from value type of input range");
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      .          .          .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      .          .          .                .          .          .                .          .          .                 // Trivial types can have deleted assignment, so using std::copy
      .          .          .                .          .          .                .          .          .                 // would be ill-formed. Require assignability before using std::copy:
 16,740 ( 0.03%) 0          0                0          0          0           16,740 ( 0.12%) 0          0                 const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 return std::__uninitialized_copy<__is_trivial(_ValueType1)
      .          .          .                .          .          .                .          .          .           				       && __is_trivial(_ValueType2)
      .          .          .                .          .          .                .          .          .           				       && __assignable>::
100,440 ( 0.20%) 1 ( 0.03%) 1 ( 0.04%)  50,220 ( 0.28%) 0          0           16,740 ( 0.12%) 0          0           	__uninit_copy(__first, __last, __result);
 33,480 ( 0.07%) 0          0           33,480 ( 0.19%) 0          0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /// @cond undocumented
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .          .          .                .          .          .                .          .          .               struct __uninitialized_fill
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Tp>
      .          .          .                .          .          .                .          .          .                   static void
-- line 159 ----------------------------------------
-- line 315 ----------------------------------------
      .          .          .                .          .          .                .          .          .           	{
      .          .          .                .          .          .                .          .          .           	  std::_Destroy(__result, __cur, __alloc);
      .          .          .                .          .          .                .          .          .           	  __throw_exception_again;
      .          .          .                .          .          .                .          .          .           	}
      .          .          .                .          .          .                .          .          .               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
      .          .          .                .          .          .                .          .          .               inline _ForwardIterator
117,180 ( 0.24%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0           83,700 ( 0.62%) 0          0               __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      .          .          .                .          .          .                .          .          .           			   _ForwardIterator __result, allocator<_Tp>&)
133,920 ( 0.27%) 0          0           83,700 ( 0.47%) 0          0           16,740 ( 0.12%) 0          0               { return std::uninitialized_copy(__first, __last, __result); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator,
      .          .          .                .          .          .                .          .          .           	   typename _Allocator>
      .          .          .                .          .          .                .          .          .               inline _ForwardIterator
      .          .          .                .          .          .                .          .          .               __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      .          .          .                .          .          .                .          .          .           			   _ForwardIterator __result, _Allocator& __alloc)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
      .          .          .                .          .          .                .          .          .           					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
      .          .          .                .          .          .                .          .          .           					 __result, __alloc);
      .          .          .                .          .          .                .          .          .               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator,
      .          .          .                .          .          .                .          .          .           	   typename _Allocator>
      .          .          .                .          .          .                .          .          .               inline _ForwardIterator
133,904 ( 0.27%) 0          0                0          0          0          100,428 ( 0.75%) 0          0               __uninitialized_move_if_noexcept_a(_InputIterator __first,
      .          .          .                .          .          .                .          .          .           				       _InputIterator __last,
      .          .          .                .          .          .                .          .          .           				       _ForwardIterator __result,
      .          .          .                .          .          .                .          .          .           				       _Allocator& __alloc)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 return std::__uninitialized_copy_a
234,332 ( 0.47%) 1 ( 0.03%) 1 ( 0.04%)  66,952 ( 0.38%) 0          0           50,214 ( 0.37%) 0          0           	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      .          .          .                .          .          .                .          .          .           	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
 50,214 ( 0.10%) 0          0           50,214 ( 0.28%) 0          0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Tp, typename _Allocator>
      .          .          .                .          .          .                .          .          .               void
      .          .          .                .          .          .                .          .          .               __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      .          .          .                .          .          .                .          .          .           			   const _Tp& __x, _Allocator& __alloc)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 _ForwardIterator __cur = __first;
      .          .          .                .          .          .                .          .          .                 __try
-- line 357 ----------------------------------------
-- line 553 ----------------------------------------
      .          .          .                .          .          .                .          .          .           	}
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .          .          .                .          .          .                .          .          .               struct __uninitialized_default_n_1
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Size>
      .          .          .                .          .          .                .          .          .                   static _ForwardIterator
     11 ( 0.00%) 0          0                0          0          0                7 ( 0.00%) 0          0                   __uninit_default_n(_ForwardIterator __first, _Size __n)
      .          .          .                .          .          .                .          .          .                   {
      4 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       2 ( 0.00%) 0          0                2 ( 0.00%) 0          0           	  _ForwardIterator __cur = __first;
      .          .          .                .          .          .                .          .          .           	  __try
      .          .          .                .          .          .                .          .          .           	    {
150,714 ( 0.30%) 0          0           90,428 ( 0.51%) 0          0                0          0          0           	      for (; __n > 0; --__n, (void) ++__cur)
150,710 ( 0.30%) 0          0           30,142 ( 0.17%) 0          0           60,284 ( 0.45%) 0          0           		std::_Construct(std::__addressof(*__cur));
      3 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0          0          0           	      return __cur;
      .          .          .                .          .          .                .          .          .           	    }
      .          .          .                .          .          .                .          .          .           	  __catch(...)
      .          .          .                .          .          .                .          .          .           	    {
      .          .          .                .          .          .                .          .          .           	      std::_Destroy(__first, __cur);
      .          .          .                .          .          .                .          .          .           	      __throw_exception_again;
      .          .          .                .          .          .                .          .          .           	    }
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       5 ( 0.00%) 0          0                0          0          0           	}
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<>
      .          .          .                .          .          .                .          .          .               struct __uninitialized_default_n_1<true>
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Size>
      .          .          .                .          .          .                .          .          .                   static _ForwardIterator
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                3 ( 0.00%) 0          0                   __uninit_default_n(_ForwardIterator __first, _Size __n)
      .          .          .                .          .          .                .          .          .                   {
      .          .          .                .          .          .                .          .          .           	  typedef typename iterator_traits<_ForwardIterator>::value_type
      .          .          .                .          .          .                .          .          .           	    _ValueType;
      .          .          .                .          .          .                .          .          .           
      8 ( 0.00%) 0          0                2 ( 0.00%) 0          0                2 ( 0.00%) 0          0           	  return std::fill_n(__first, __n, _ValueType());
      2 ( 0.00%) 0          0                2 ( 0.00%) 1 ( 0.00%) 0                0          0          0           	}
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             // __uninitialized_default
      .          .          .                .          .          .                .          .          .             // Fills [first, last) with std::distance(first, last) default
      .          .          .                .          .          .                .          .          .             // constructed value_types(s).
      .          .          .                .          .          .                .          .          .             template<typename _ForwardIterator>
      .          .          .                .          .          .                .          .          .               inline void
      .          .          .                .          .          .                .          .          .               __uninitialized_default(_ForwardIterator __first,
-- line 597 ----------------------------------------
-- line 606 ----------------------------------------
      .          .          .                .          .          .                .          .          .           				     && __assignable>::
      .          .          .                .          .          .                .          .          .           	__uninit_default(__first, __last);
      .          .          .                .          .          .                .          .          .               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             // __uninitialized_default_n
      .          .          .                .          .          .                .          .          .             // Fills [first, first + n) with n default constructed value_type(s).
      .          .          .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Size>
      .          .          .                .          .          .                .          .          .               inline _ForwardIterator
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                9 ( 0.00%) 0          0               __uninitialized_default_n(_ForwardIterator __first, _Size __n)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .          .          .                .          .          .                .          .          .           	_ValueType;
      .          .          .                .          .          .                .          .          .                 // trivial types can have deleted assignment
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                3 ( 0.00%) 0          0                 const bool __assignable = is_copy_assignable<_ValueType>::value;
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 return __uninitialized_default_n_1<__is_trivial(_ValueType)
      .          .          .                .          .          .                .          .          .           				       && __assignable>::
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       6 ( 0.00%) 0          0                3 ( 0.00%) 0          0           	__uninit_default_n(__first, __n);
      6 ( 0.00%) 0          0                6 ( 0.00%) 2 ( 0.00%) 1 ( 0.01%)       0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             // __uninitialized_default_a
      .          .          .                .          .          .                .          .          .             // Fills [first, last) with std::distance(first, last) default
      .          .          .                .          .          .                .          .          .             // constructed value_types(s), constructed with the allocator alloc.
      .          .          .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Allocator>
      .          .          .                .          .          .                .          .          .               void
      .          .          .                .          .          .                .          .          .               __uninitialized_default_a(_ForwardIterator __first,
-- line 632 ----------------------------------------
-- line 675 ----------------------------------------
      .          .          .                .          .          .                .          .          .           	{
      .          .          .                .          .          .                .          .          .           	  std::_Destroy(__first, __cur, __alloc);
      .          .          .                .          .          .                .          .          .           	  __throw_exception_again;
      .          .          .                .          .          .                .          .          .           	}
      .          .          .                .          .          .                .          .          .               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Size, typename _Tp>
      .          .          .                .          .          .                .          .          .               inline _ForwardIterator
     18 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0               12 ( 0.00%) 0          0               __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
      .          .          .                .          .          .                .          .          .           				allocator<_Tp>&)
     21 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)      12 ( 0.00%) 3 ( 0.00%) 0                3 ( 0.00%) 0          0               { return std::__uninitialized_default_n(__first, __n); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .          .          .                .          .          .                .          .          .               struct __uninitialized_default_novalue_1
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 template<typename _ForwardIterator>
      .          .          .                .          .          .                .          .          .           	static void
      .          .          .                .          .          .                .          .          .           	__uninit_default_novalue(_ForwardIterator __first,
      .          .          .                .          .          .                .          .          .           				 _ForwardIterator __last)
-- line 693 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/simulator.cpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr              D1mr            DLmr        Dw               D1mw       DLmw       

-- line 2 ----------------------------------------
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .           #include <cstddef>
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .           namespace sim {
      .          .          .               .               .           .                .          .          .               /**
      .          .          .               .               .           .                .          .          .                * Constructor de la calse simulador
      .          .          .               .               .           .                .          .          .                * @param args_view: Span con el que se construye args_parser para la comprobacion de argumentos
      .          .          .               .               .           .                .          .          .                */
     11 ( 0.00%) 0          0               0               0           0                5 ( 0.00%) 0          0               Simulator::Simulator(const std::span<const char *> args_view) :
      .          .          .               .               .           .                .          .          .                       args_parser_(args_view),
     20 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)      7 ( 0.00%)      0           0                5 ( 0.00%) 0          0                       nts_(0) {
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      3 ( 0.00%)      0           0                0          0          0               }
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .               /**
      .          .          .               .               .           .                .          .          .                * Representa la primera etapa de la simulacion, utilza la clase Proargs para comprobar que los argumentos son
      .          .          .               .               .           .                .          .          .                * correctos.
      .          .          .               .               .           .                .          .          .                * @return Devuelve SUCCESS (0) si los argumentos pasados por el usuario eran correctos o bien el error
      .          .          .               .               .           .                .          .          .                * correspondiente
      .          .          .               .               .           .                .          .          .                */
      4 ( 0.00%) 0          0               0               0           0                2 ( 0.00%) 0          0               sim::error_code Simulator::ParseArgs() {
      1 ( 0.00%) 0          0               0               0           0                1 ( 0.00%) 0          0                   error_code err = SUCCESS;
      .          .          .               .               .           .                .          .          .           
      4 ( 0.00%) 0          0               1 ( 0.00%)      0           0                2 ( 0.00%) 0          0                   err = args_parser_.CheckCount();
      2 ( 0.00%) 0          0               1 ( 0.00%)      0           0                0          0          0                   if (err != SUCCESS) { //[[likely]] o [[unlikely]]?
      .          .          .               .               .           .                .          .          .                       return (err);
      .          .          .               .               .           .                .          .          .                   }
      .          .          .               .               .           .                .          .          .           
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      2 ( 0.00%)      0           0                2 ( 0.00%) 0          0                   err = args_parser_.CheckNts(nts_);
      2 ( 0.00%) 0          0               1 ( 0.00%)      0           0                0          0          0                   if (err != 0) {
      .          .          .               .               .           .                .          .          .                       return (err);
      .          .          .               .               .           .                .          .          .                   }
      .          .          .               .               .           .                .          .          .           
      9 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      3 ( 0.00%)      0           0                2 ( 0.00%) 0          0                   err = args_parser_.CheckOpenFiles(init_file_, final_file_);
      2 ( 0.00%) 0          0               1 ( 0.00%)      0           0                0          0          0                   if (err != SUCCESS) {
      .          .          .               .               .           .                .          .          .                       return (err);
      .          .          .               .               .           .                .          .          .                   }
      1 ( 0.00%) 0          0               1 ( 0.00%)      0           0                0          0          0                   return (err);
      2 ( 0.00%) 0          0               2 ( 0.00%)      0           0                0          0          0               }
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .               /**
      .          .          .               .               .           .                .          .          .                * Representa la segunda fase de la simulacion, donde se inicializa la simulacion, se lee el
      .          .          .               .               .           .                .          .          .                * fichero de entrada y se inicializa el grid con dicha informacion
      .          .          .               .               .           .                .          .          .                * @return
      .          .          .               .               .           .                .          .          .                */
      5 ( 0.00%) 0          0               0               0           0                3 ( 0.00%) 0          0               sim::error_code Simulator::InitSim() {
      1 ( 0.00%) 0          0               0               0           0                1 ( 0.00%) 0          0                   sim::error_code err = SUCCESS;
      6 ( 0.00%) 0          0               0               0           0                2 ( 0.00%) 0          0                   std::vector<Particle> particles;
      1 ( 0.00%) 0          0               0               0           0                1 ( 0.00%) 0          0                   int num_particles = 0;
      2 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      0               0           0                1 ( 0.00%) 0          0                   double ppm = 0.0;
      .          .          .               .               .           .                .          .          .           
      8 ( 0.00%) 0          0               1 ( 0.00%)      0           0                2 ( 0.00%) 0          0                   err = init_file_.ReadHeader(ppm, num_particles);
      2 ( 0.00%) 0          0               1 ( 0.00%)      0           0                0          0          0                   if (err != SUCCESS) {
      .          .          .               .               .           .                .          .          .                       return (err);
      .          .          .               .               .           .                .          .          .                   }
      .          .          .               .               .           .                .          .          .           
     14 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      1 ( 0.00%)      0           0                3 ( 0.00%) 0          0                   particles = init_file_.ReadParticles();
      7 ( 0.00%) 0          0               1 ( 0.00%)      0           0                1 ( 0.00%) 0          0                   grid_.emplace(num_particles, ppm, particles);
      1 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      1 ( 0.00%)      1 ( 0.00%)  0                0          0          0                   return (err);
      5 ( 0.00%) 0          0               3 ( 0.00%)      1 ( 0.00%)  0                0          0          0               }
      .          .          .               .               .           .                .          .          .                   /**
      .          .          .               .               .           .                .          .          .                    * Representa la tercera fase de la simulacion, donde se procesan los calculos necesarios tantas veces como el
      .          .          .               .               .           .                .          .          .                    * usuario indico por argumento
      .          .          .               .               .           .                .          .          .                    * @return
      .          .          .               .               .           .                .          .          .                    */
      3 ( 0.00%) 0          0               0               0           0                2 ( 0.00%) 0          0                   sim::error_code Simulator::ProcessSim() {
     65 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)     43 ( 0.00%)      0           0                1 ( 0.00%) 0          0                       for (int i = 0; i < nts_; i++) {
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .                       }
      1 ( 0.00%) 0          0               0               0           0                0          0          0                       return (SUCCESS);
      2 ( 0.00%) 0          0               2 ( 0.00%)      0           0                0          0          0                   }
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .                   /**
      .          .          .               .               .           .                .          .          .                    * Representa la ultima fase de la simulacion, se almacenan los resultados en el fichero especificado por parametro
      .          .          .               .               .           .                .          .          .                    * @return
      .          .          .               .               .           .                .          .          .                    */
      5 ( 0.00%) 0          0               0               0           0                3 ( 0.00%) 0          0                   sim::error_code Simulator::StoreResults() {
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      1 ( 0.00%)      0           0                3 ( 0.00%) 0          0                       const int num_particles = grid_->GetNumParticles();
     16 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)      1 ( 0.00%)      0           0                4 ( 0.00%) 0          0                       std::vector<Particle> results(num_particles);
      .          .          .               .               .           .                .          .          .           
     14 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      3 ( 0.00%)      1 ( 0.00%)  0                3 ( 0.00%) 0          0                       final_file_.WriteHeader(num_particles, grid_->GetParticlesPerMeter());
      .          .          .               .               .           .                .          .          .           
240,087 ( 0.48%) 1 ( 0.03%) 1 ( 0.04%)      3 ( 0.00%)      0           0           60,024 ( 0.45%) 0          0                       for(auto& block: grid_->GetBlocks()){
542,288 ( 1.09%) 3 ( 0.09%) 3 ( 0.11%) 45,012 ( 0.26%)      0           0          165,580 ( 1.23%) 0          0                          for(auto& particle : block.GetParticles()){
166,518 ( 0.34%) 0          0          45,414 ( 0.26%) 11,846 ( 6.78%) 11 ( 0.11%)  30,276 ( 0.22%) 0          0                              results[particle.id] = particle;
      .          .          .               .               .           .                .          .          .                          }
      .          .          .               .               .           .                .          .          .                       }
      .          .          .               .               .           .                .          .          .           
      6 ( 0.00%) 0          0               1 ( 0.00%)      0           0                1 ( 0.00%) 0          0                       final_file_.WriteParticles(results);
      3 ( 0.00%) 0          0               0               0           0                0          0          0                       return (SUCCESS);
      3 ( 0.00%) 0          0               3 ( 0.00%)      1 ( 0.00%)  0                0          0          0                   }
      .          .          .               .               .           .                .          .          .           
      .          .          .               .               .           .                .          .          .               }  // namespace sim

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/array
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 47 ----------------------------------------
      .          .          .                .          .          .                .          .          .             template<typename _Tp, std::size_t _Nm>
      .          .          .                .          .          .                .          .          .               struct __array_traits
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 typedef _Tp _Type[_Nm];
      .          .          .                .          .          .                .          .          .                 typedef __is_swappable<_Tp> _Is_swappable;
      .          .          .                .          .          .                .          .          .                 typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 static constexpr _Tp&
544,968 ( 1.10%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0          408,726 ( 3.03%) 0          0                 _S_ref(const _Type& __t, std::size_t __n) noexcept
817,452 ( 1.65%) 0          0          544,968 ( 3.09%) 0          0                0          0          0                 { return const_cast<_Tp&>(__t[__n]); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 static constexpr _Tp*
 45,414 ( 0.09%) 0          0                0          0          0           30,276 ( 0.22%) 0          0                 _S_ptr(const _Type& __t) noexcept
 45,414 ( 0.09%) 0          0           45,414 ( 0.26%) 0          0                0          0          0                 { return const_cast<_Tp*>(__t); }
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .            template<typename _Tp>
      .          .          .                .          .          .                .          .          .              struct __array_traits<_Tp, 0>
      .          .          .                .          .          .                .          .          .              {
      .          .          .                .          .          .                .          .          .                struct _Type { };
      .          .          .                .          .          .                .          .          .                typedef true_type _Is_swappable;
      .          .          .                .          .          .                .          .          .                typedef true_type _Is_nothrow_swappable;
-- line 68 ----------------------------------------
-- line 177 ----------------------------------------
      .          .          .                .          .          .                .          .          .                 constexpr size_type
      .          .          .                .          .          .                .          .          .                 max_size() const noexcept { return _Nm; }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 _GLIBCXX_NODISCARD constexpr bool
      .          .          .                .          .          .                .          .          .                 empty() const noexcept { return size() == 0; }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 // Element access.
      .          .          .                .          .          .                .          .          .                 _GLIBCXX17_CONSTEXPR reference
681,210 ( 1.37%) 1 ( 0.03%) 0                0          0          0          408,726 ( 3.03%) 0          0                 operator[](size_type __n) noexcept
953,694 ( 1.92%) 1 ( 0.03%) 1 ( 0.04%) 544,968 ( 3.09%) 0          0          136,242 ( 1.01%) 0          0                 { return _AT_Type::_S_ref(_M_elems, __n); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 constexpr const_reference
      .          .          .                .          .          .                .          .          .                 operator[](size_type __n) const noexcept
      .          .          .                .          .          .                .          .          .                 { return _AT_Type::_S_ref(_M_elems, __n); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 _GLIBCXX17_CONSTEXPR reference
      .          .          .                .          .          .                .          .          .                 at(size_type __n)
      .          .          .                .          .          .                .          .          .                 {
-- line 194 ----------------------------------------
-- line 226 ----------------------------------------
      .          .          .                .          .          .                .          .          .                 constexpr const_reference
      .          .          .                .          .          .                .          .          .                 back() const noexcept
      .          .          .                .          .          .                .          .          .                 {
      .          .          .                .          .          .                .          .          .           	return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
      .          .          .                .          .          .                .          .          .            	           : _AT_Type::_S_ref(_M_elems, 0);
      .          .          .                .          .          .                .          .          .                 }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 _GLIBCXX17_CONSTEXPR pointer
 60,552 ( 0.12%) 0          0                0          0          0           30,276 ( 0.22%) 0          0                 data() noexcept
 75,690 ( 0.15%) 0          0           45,414 ( 0.26%) 0          0           15,138 ( 0.11%) 0          0                 { return _AT_Type::_S_ptr(_M_elems); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 _GLIBCXX17_CONSTEXPR const_pointer
      .          .          .                .          .          .                .          .          .                 data() const noexcept
      .          .          .                .          .          .                .          .          .                 { return _AT_Type::_S_ptr(_M_elems); }
      .          .          .                .          .          .                .          .          .               };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #if __cpp_deduction_guides >= 201606
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename... _Up>
-- line 243 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/ext/new_allocator.h
--------------------------------------------------------------------------------
Ir              I1mr       ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 71 ----------------------------------------
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           #if __cplusplus >= 201103L
     .          .          .               .          .          .               .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
     .          .          .               .          .          .               .          .          .                 // 2103. propagate_on_container_move_assignment
     .          .          .               .          .          .               .          .          .                 typedef std::true_type propagate_on_container_move_assignment;
     .          .          .               .          .          .               .          .          .           #endif
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .                 _GLIBCXX20_CONSTEXPR
90,060 ( 0.18%) 6 ( 0.19%) 5 ( 0.19%) 30,020 ( 0.17%) 0          0          30,020 ( 0.22%) 0          0                 new_allocator() _GLIBCXX_USE_NOEXCEPT { }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .                 _GLIBCXX20_CONSTEXPR
    77 ( 0.00%) 3 ( 0.09%) 3 ( 0.11%)     22 ( 0.00%) 0          0              33 ( 0.00%) 0          0                 new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .                 template<typename _Tp1>
     .          .          .               .          .          .               .          .          .           	_GLIBCXX20_CONSTEXPR
     .          .          .               .          .          .               .          .          .           	new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           #if __cplusplus <= 201703L
     .          .          .               .          .          .               .          .          .                 ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
     .          .          .               .          .          .               .          .          .           
-- line 90 ----------------------------------------
-- line 95 ----------------------------------------
     .          .          .               .          .          .               .          .          .                 const_pointer
     .          .          .               .          .          .               .          .          .                 address(const_reference __x) const _GLIBCXX_NOEXCEPT
     .          .          .               .          .          .               .          .          .                 { return std::__addressof(__x); }
     .          .          .               .          .          .               .          .          .           #endif
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .                 // NB: __n is permitted to be 0.  The C++ standard says nothing
     .          .          .               .          .          .               .          .          .                 // about what the return value is when __n == 0.
     .          .          .               .          .          .               .          .          .                 _GLIBCXX_NODISCARD _Tp*
50,244 ( 0.10%) 5 ( 0.16%) 4 ( 0.15%)      0          0          0          33,496 ( 0.25%) 0          0                 allocate(size_type __n, const void* = static_cast<const void*>(0))
     .          .          .               .          .          .               .          .          .                 {
58,618 ( 0.12%) 0          0          16,748 ( 0.09%) 0          0           8,374 ( 0.06%) 0          0           	if (__n > this->_M_max_size())
     .          .          .               .          .          .               .          .          .           	  std::__throw_bad_alloc();
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           #if __cpp_aligned_new
     .          .          .               .          .          .               .          .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
     .          .          .               .          .          .               .          .          .           	  {
     .          .          .               .          .          .               .          .          .           	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
     .          .          .               .          .          .               .          .          .           	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
     .          .          .               .          .          .               .          .          .           	  }
     .          .          .               .          .          .               .          .          .           #endif
66,986 ( 0.14%) 2 ( 0.06%) 2 ( 0.07%)  8,374 ( 0.05%) 0          0           8,374 ( 0.06%) 0          0           	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
16,748 ( 0.03%) 0          0          16,748 ( 0.09%) 0          0               0          0          0                 }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .                 // __p is not permitted to be a null pointer.
     .          .          .               .          .          .               .          .          .                 void
50,244 ( 0.10%) 0          0               0          0          0          33,496 ( 0.25%) 1 ( 0.00%) 0                 deallocate(_Tp* __p, size_type __t)
     .          .          .               .          .          .               .          .          .                 {
     .          .          .               .          .          .               .          .          .           #if __cpp_aligned_new
     .          .          .               .          .          .               .          .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
     .          .          .               .          .          .               .          .          .           	  {
     .          .          .               .          .          .               .          .          .           	    ::operator delete(__p,
     .          .          .               .          .          .               .          .          .           # if __cpp_sized_deallocation
     .          .          .               .          .          .               .          .          .           			      __t * sizeof(_Tp),
     .          .          .               .          .          .               .          .          .           # endif
     .          .          .               .          .          .               .          .          .           			      std::align_val_t(alignof(_Tp)));
     .          .          .               .          .          .               .          .          .           	    return;
     .          .          .               .          .          .               .          .          .           	  }
     .          .          .               .          .          .               .          .          .           #endif
83,732 ( 0.17%) 0          0          16,748 ( 0.09%) 0          0           8,374 ( 0.06%) 0          0           	::operator delete(__p
     .          .          .               .          .          .               .          .          .           #if __cpp_sized_deallocation
     .          .          .               .          .          .               .          .          .           			  , __t * sizeof(_Tp)
     .          .          .               .          .          .               .          .          .           #endif
     .          .          .               .          .          .               .          .          .           			 );
16,748 ( 0.03%) 0          0          16,748 ( 0.09%) 0          0               0          0          0                 }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           #if __cplusplus <= 201703L
     .          .          .               .          .          .               .          .          .                 size_type
     .          .          .               .          .          .               .          .          .                 max_size() const _GLIBCXX_USE_NOEXCEPT
     .          .          .               .          .          .               .          .          .                 { return _M_max_size(); }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           #if __cplusplus >= 201103L
     .          .          .               .          .          .               .          .          .                 template<typename _Up, typename... _Args>
-- line 146 ----------------------------------------
-- line 177 ----------------------------------------
     .          .          .               .          .          .               .          .          .           	friend _GLIBCXX20_CONSTEXPR bool
     .          .          .               .          .          .               .          .          .           	operator!=(const new_allocator&, const new_allocator<_Up>&)
     .          .          .               .          .          .               .          .          .           	_GLIBCXX_NOTHROW
     .          .          .               .          .          .               .          .          .           	{ return false; }
     .          .          .               .          .          .               .          .          .           #endif
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .               private:
     .          .          .               .          .          .               .          .          .                 _GLIBCXX_CONSTEXPR size_type
25,122 ( 0.05%) 7 ( 0.22%) 4 ( 0.15%)      0          0          0          16,748 ( 0.12%) 0          0                 _M_max_size() const _GLIBCXX_USE_NOEXCEPT
     .          .          .               .          .          .               .          .          .                 {
     .          .          .               .          .          .               .          .          .           #if __PTRDIFF_MAX__ < __SIZE_MAX__
 8,374 ( 0.02%) 1 ( 0.03%) 1 ( 0.04%)      0          0          0               0          0          0           	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
     .          .          .               .          .          .               .          .          .           #else
     .          .          .               .          .          .               .          .          .           	return std::size_t(-1) / sizeof(_Tp);
     .          .          .               .          .          .               .          .          .           #endif
16,748 ( 0.03%) 0          0          16,748 ( 0.09%) 0          0               0          0          0                 }
     .          .          .               .          .          .               .          .          .               };
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           _GLIBCXX_END_NAMESPACE_VERSION
     .          .          .               .          .          .               .          .          .           } // namespace
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/grid/block.hpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

      .          .          .               .          .          .               .          .          .           #include <vector>
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #include "sim/utils/vector.hpp"
      .          .          .               .          .          .               .          .          .           #include "sim/grid/particle.hpp"
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           namespace sim {
150,040 ( 0.30%) 0          0          45,012 ( 0.26%) 0          0          45,012 ( 0.33%) 0          0               class Block {
      .          .          .               .          .          .               .          .          .               public:
150,040 ( 0.30%) 0          0          45,012 ( 0.26%) 0          0          45,012 ( 0.33%) 0          0                   Block() = default;
      .          .          .               .          .          .               .          .          .                   void AddParticle(Particle& particle);
      .          .          .               .          .          .               .          .          .                   [[nodiscard]] std::vector<Particle>& GetParticles();
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .               private:
      .          .          .               .          .          .               .          .          .                   std::vector<Particle> particles_;
      .          .          .               .          .          .               .          .          .               };
      .          .          .               .          .          .               .          .          .           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr            DLmr       Dw               D1mw       DLmw       

-- line 89 ----------------------------------------
      .          .          .                .               .          .                .          .          .                  	pointer;
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 struct _Vector_impl_data
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	pointer _M_start;
      .          .          .                .               .          .                .          .          .           	pointer _M_finish;
      .          .          .                .               .          .                .          .          .           	pointer _M_end_of_storage;
      .          .          .                .               .          .                .          .          .           
 45,039 ( 0.09%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0           30,026 ( 0.22%) 0          0           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
 90,078 ( 0.18%) 1 ( 0.03%) 1 ( 0.04%)  45,039 ( 0.26%)      0          0           45,039 ( 0.33%) 0          0           	: _M_start(), _M_finish(), _M_end_of_storage()
 45,039 ( 0.09%) 0          0           30,026 ( 0.17%)      0          0                0          0          0           	{ }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      4 ( 0.00%) 0          0                0               0          0                3 ( 0.00%) 0          0           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
      4 ( 0.00%) 0          0                4 ( 0.00%)      0          0                0          0          0           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       5 ( 0.00%)      0          0                3 ( 0.00%) 1 ( 0.00%) 0           	  _M_end_of_storage(__x._M_end_of_storage)
     13 ( 0.00%) 0          0                9 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           	void
     24 ( 0.00%) 0          0                0               0          0               18 ( 0.00%) 0          0           	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .           	{
     24 ( 0.00%) 0          0               18 ( 0.00%)      0          0                6 ( 0.00%) 0          0           	  _M_start = __x._M_start;
     24 ( 0.00%) 0          0               18 ( 0.00%)      0          0                6 ( 0.00%) 0          0           	  _M_finish = __x._M_finish;
     24 ( 0.00%) 0          0               18 ( 0.00%)      0          0                6 ( 0.00%) 0          0           	  _M_end_of_storage = __x._M_end_of_storage;
     18 ( 0.00%) 0          0               12 ( 0.00%)      0          0                0          0          0           	}
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           	void
     10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                6 ( 0.00%) 0          0           	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .           	{
      .          .          .                .               .          .                .          .          .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
      .          .          .                .               .          .                .          .          .           	  // information used by TBAA.
      6 ( 0.00%) 0          0                0               0          0                2 ( 0.00%) 0          0           	  _Vector_impl_data __tmp;
     10 ( 0.00%) 0          0                2 ( 0.00%)      0          0                2 ( 0.00%) 0          0           	  __tmp._M_copy_data(*this);
     10 ( 0.00%) 0          0                4 ( 0.00%)      0          0                2 ( 0.00%) 0          0           	  _M_copy_data(__x);
     10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                2 ( 0.00%) 0          0           	  __x._M_copy_data(__tmp);
      6 ( 0.00%) 0          0                4 ( 0.00%)      0          0                0          0          0           	}
      .          .          .                .               .          .                .          .          .                 };
      .          .          .                .               .          .                .          .          .           
150,120 ( 0.30%) 3 ( 0.09%) 0           45,036 ( 0.26%)      0          0           45,036 ( 0.33%) 0          0                 struct _Vector_impl
      .          .          .                .               .          .                .          .          .           	: public _Tp_alloc_type, public _Vector_impl_data
      .          .          .                .               .          .                .          .          .                 {
 60,024 ( 0.12%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0           30,012 ( 0.22%) 0          0           	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
      .          .          .                .               .          .                .          .          .           	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
 90,036 ( 0.18%) 0          0           30,012 ( 0.17%)      0          0           30,012 ( 0.22%) 0          0           	: _Tp_alloc_type()
 45,018 ( 0.09%) 0          0           30,012 ( 0.17%)      0          0                0          0          0           	{ }
      .          .          .                .               .          .                .          .          .           
     25 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0               15 ( 0.00%) 0          0           	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
     40 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      15 ( 0.00%)      0          0               10 ( 0.00%) 0          0           	: _Tp_alloc_type(__a)
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      10 ( 0.00%)      0          0                0          0          0           	{ }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .           	// Not defaulted, to enforce noexcept(true) even when
      .          .          .                .               .          .                .          .          .           	// !is_nothrow_move_constructible<_Tp_alloc_type>.
      6 ( 0.00%) 0          0                0               0          0                4 ( 0.00%) 0          0           	_Vector_impl(_Vector_impl&& __x) noexcept
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0                4 ( 0.00%) 0          0           	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
      4 ( 0.00%) 0          0                3 ( 0.00%)      0          0                0          0          0           	{ }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           	_Vector_impl(_Tp_alloc_type&& __a) noexcept
      .          .          .                .               .          .                .          .          .           	: _Tp_alloc_type(std::move(__a))
      .          .          .                .               .          .                .          .          .           	{ }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
      .          .          .                .               .          .                .          .          .           	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
      .          .          .                .               .          .                .          .          .           	{ }
-- line 153 ----------------------------------------
-- line 268 ----------------------------------------
      .          .          .                .               .          .                .          .          .           #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
      .          .          .                .               .          .                .          .          .           #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
      .          .          .                .               .          .                .          .          .                 };
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               public:
      .          .          .                .               .          .                .          .          .                 typedef _Alloc allocator_type;
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 _Tp_alloc_type&
120,384 ( 0.24%) 5 ( 0.16%) 5 ( 0.19%)       0               0          0           80,256 ( 0.60%) 0          0                 _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
120,384 ( 0.24%) 1 ( 0.03%) 1 ( 0.04%) 120,384 ( 0.68%)      0          0                0          0          0                 { return this->_M_impl; }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 const _Tp_alloc_type&
 50,220 ( 0.10%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0           33,480 ( 0.25%) 0          0                 _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
 50,220 ( 0.10%) 0          0           50,220 ( 0.28%)      0          0                0          0          0                 { return this->_M_impl; }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 allocator_type
      5 ( 0.00%) 0          0                0               0          0                3 ( 0.00%) 0          0                 get_allocator() const _GLIBCXX_NOEXCEPT
     11 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       5 ( 0.00%)      0          0                2 ( 0.00%) 0          0                 { return allocator_type(_M_get_Tp_allocator()); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
150,060 ( 0.30%) 0          0           45,018 ( 0.26%)      0          0           45,018 ( 0.33%) 0          0                 _Vector_base() = default;
      .          .          .                .               .          .                .          .          .           #else
      .          .          .                .               .          .                .          .          .                 _Vector_base() { }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
     10 ( 0.00%) 0          0                0               0          0                6 ( 0.00%) 0          0                 _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
     16 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       8 ( 0.00%)      0          0                2 ( 0.00%) 0          0                 : _M_impl(__a) { }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Kept for ABI compatibility.
      .          .          .                .               .          .                .          .          .           #if !_GLIBCXX_INLINE_VERSION
      .          .          .                .               .          .                .          .          .                 _Vector_base(size_t __n)
      .          .          .                .               .          .                .          .          .                 : _M_impl()
      .          .          .                .               .          .                .          .          .                 { _M_create_storage(__n); }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
     21 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0               15 ( 0.00%) 0          0                 _Vector_base(size_t __n, const allocator_type& __a)
     15 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       6 ( 0.00%)      0          0                3 ( 0.00%) 0          0                 : _M_impl(__a)
     27 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      15 ( 0.00%)      0          0                3 ( 0.00%) 0          0                 { _M_create_storage(__n); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
     13 ( 0.00%) 0          0                4 ( 0.00%)      0          0                4 ( 0.00%) 0          0                 _Vector_base(_Vector_base&&) = default;
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Kept for ABI compatibility.
      .          .          .                .               .          .                .          .          .           # if !_GLIBCXX_INLINE_VERSION
      .          .          .                .               .          .                .          .          .                 _Vector_base(_Tp_alloc_type&& __a) noexcept
      .          .          .                .               .          .                .          .          .                 : _M_impl(std::move(__a)) { }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      .          .          .                .               .          .                .          .          .                 : _M_impl(__a)
-- line 316 ----------------------------------------
-- line 325 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 }
      .          .          .                .               .          .                .          .          .           # endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      .          .          .                .               .          .                .          .          .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      .          .          .                .               .          .                .          .          .                 { }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
 60,048 ( 0.12%) 2 ( 0.06%) 1 ( 0.04%)       0               0          0           30,024 ( 0.22%) 0          0                 ~_Vector_base() _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
105,084 ( 0.21%) 0          0           45,036 ( 0.26%)      0          0           15,012 ( 0.11%) 0          0           	_M_deallocate(_M_impl._M_start,
150,114 ( 0.30%) 1 ( 0.03%) 1 ( 0.04%)  60,048 ( 0.34%)  1,878 ( 1.07%) 0                0          0          0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
 90,072 ( 0.18%) 0          0           45,036 ( 0.26%)      0          0           15,012 ( 0.11%) 0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               public:
      .          .          .                .               .          .                .          .          .                 _Vector_impl _M_impl;
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 pointer
 41,870 ( 0.08%) 2 ( 0.06%) 1 ( 0.04%)       0               0          0           25,122 ( 0.19%) 0          0                 _M_allocate(size_t __n)
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 66,992 ( 0.14%) 2 ( 0.06%) 2 ( 0.07%)  25,122 ( 0.14%)      0          0            8,374 ( 0.06%) 0          0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
 16,748 ( 0.03%) 0          0           16,748 ( 0.09%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 void
140,292 ( 0.28%) 2 ( 0.06%) 0                0               0          0           93,528 ( 0.69%) 0          0                 _M_deallocate(pointer __p, size_t __n)
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 46,764 ( 0.09%) 0          0           23,382 ( 0.13%)      0          0                0          0          0           	if (__p)
 50,244 ( 0.10%) 0          0           25,122 ( 0.14%)      0          0            8,374 ( 0.06%) 0          0           	  _Tr::deallocate(_M_impl, __p, __n);
 70,146 ( 0.14%) 0          0           46,764 ( 0.27%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               protected:
      .          .          .                .               .          .                .          .          .                 void
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                9 ( 0.00%) 0          0                 _M_create_storage(size_t __n)
      .          .          .                .               .          .                .          .          .                 {
     21 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       9 ( 0.00%)      0          0                6 ( 0.00%) 0          0           	this->_M_impl._M_start = this->_M_allocate(__n);
     12 ( 0.00%) 0          0                9 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	this->_M_impl._M_finish = this->_M_impl._M_start;
     27 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      12 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      9 ( 0.00%) 0          0                6 ( 0.00%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .               };
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .             /**
      .          .          .                .               .          .                .          .          .              *  @brief A standard container which offers fixed time access to
      .          .          .                .               .          .                .          .          .              *  individual elements in any order.
      .          .          .                .               .          .                .          .          .              *
      .          .          .                .               .          .                .          .          .              *  @ingroup sequences
      .          .          .                .               .          .                .          .          .              *
-- line 372 ----------------------------------------
-- line 479 ----------------------------------------
      .          .          .                .               .          .                .          .          .               public:
      .          .          .                .               .          .                .          .          .                 // [23.2.4.1] construct/copy/destroy
      .          .          .                .               .          .                .          .          .                 // (assign() and get_allocator() are also listed in this section)
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Creates a %vector with no elements.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
150,060 ( 0.30%) 1 ( 0.03%) 1 ( 0.04%)  45,018 ( 0.26%)      0          0           45,018 ( 0.33%) 0          0                 vector() = default;
      .          .          .                .               .          .                .          .          .           #else
      .          .          .                .               .          .                .          .          .                 vector() { }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Creates a %vector with no elements.
      .          .          .                .               .          .                .          .          .                  *  @param  __a  An allocator object.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 explicit
      5 ( 0.00%) 0          0                0               0          0                3 ( 0.00%) 0          0                 vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      8 ( 0.00%) 0          0                4 ( 0.00%)      0          0                1 ( 0.00%) 0          0                 : _Base(__a) { }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Creates a %vector with default constructed elements.
      .          .          .                .               .          .                .          .          .                  *  @param  __n  The number of elements to initially create.
      .          .          .                .               .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This constructor fills the %vector with @a __n default
      .          .          .                .               .          .                .          .          .                  *  constructed elements.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 explicit
     24 ( 0.00%) 0          0                0               0          0               16 ( 0.00%) 0          0                 vector(size_type __n, const allocator_type& __a = allocator_type())
     36 ( 0.00%) 3 ( 0.09%) 3 ( 0.11%)      12 ( 0.00%)      0          0                6 ( 0.00%) 0          0                 : _Base(_S_check_init_len(__n, __a), __a)
     27 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)      15 ( 0.00%)      3 ( 0.00%) 0                3 ( 0.00%) 0          0                 { _M_default_initialize(__n); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Creates a %vector with copies of an exemplar element.
      .          .          .                .               .          .                .          .          .                  *  @param  __n  The number of elements to initially create.
      .          .          .                .               .          .                .          .          .                  *  @param  __value  An element to copy.
      .          .          .                .               .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 520 ----------------------------------------
-- line 564 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  %Vector move constructor.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  The newly-created %vector contains the exact contents of the
      .          .          .                .               .          .                .          .          .                  *  moved instance.
      .          .          .                .               .          .                .          .          .                  *  The contents of the moved instance are a valid, but unspecified
      .          .          .                .               .          .                .          .          .                  *  %vector.
      .          .          .                .               .          .                .          .          .                  */
     13 ( 0.00%) 0          0                4 ( 0.00%)      0          0                4 ( 0.00%) 0          0                 vector(vector&&) noexcept = default;
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /// Copy constructor with alternative allocator
      .          .          .                .               .          .                .          .          .                 vector(const vector& __x, const allocator_type& __a)
      .          .          .                .               .          .                .          .          .                 : _Base(__x.size(), __a)
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	this->_M_impl._M_finish =
      .          .          .                .               .          .                .          .          .           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
      .          .          .                .               .          .                .          .          .           				      this->_M_impl._M_start,
-- line 580 ----------------------------------------
-- line 645 ----------------------------------------
      .          .          .                .               .          .                .          .          .                  *  constructor N times (where N is distance(first,last)) and do
      .          .          .                .               .          .                .          .          .                  *  no memory reallocation.  But if only input iterators are
      .          .          .                .               .          .                .          .          .                  *  used, then this will do at most 2N calls to the copy
      .          .          .                .               .          .                .          .          .                  *  constructor, and logN memory reallocations.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .                 template<typename _InputIterator,
      .          .          .                .               .          .                .          .          .           	       typename = std::_RequireInputIter<_InputIterator>>
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                6 ( 0.00%) 0          0           	vector(_InputIterator __first, _InputIterator __last,
      3 ( 0.00%) 0          0                0               0          0                1 ( 0.00%) 0          0           	       const allocator_type& __a = allocator_type())
      5 ( 0.00%) 0          0                2 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	: _Base(__a)
      .          .          .                .               .          .                .          .          .           	{
      6 ( 0.00%) 0          0                3 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	  _M_range_initialize(__first, __last,
      3 ( 0.00%) 0          0                0               0          0                1 ( 0.00%) 0          0           			      std::__iterator_category(__first));
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%)      0          0                0          0          0           	}
      .          .          .                .               .          .                .          .          .           #else
      .          .          .                .               .          .                .          .          .                 template<typename _InputIterator>
      .          .          .                .               .          .                .          .          .           	vector(_InputIterator __first, _InputIterator __last,
      .          .          .                .               .          .                .          .          .           	       const allocator_type& __a = allocator_type())
      .          .          .                .               .          .                .          .          .           	: _Base(__a)
      .          .          .                .               .          .                .          .          .           	{
      .          .          .                .               .          .                .          .          .           	  // Check whether it's an integral type.  If so, it's not an iterator.
      .          .          .                .               .          .                .          .          .           	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
-- line 667 ----------------------------------------
-- line 670 ----------------------------------------
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  The dtor only erases the elements, and note that if the
      .          .          .                .               .          .                .          .          .                  *  elements themselves are pointers, the pointed-to memory is
      .          .          .                .               .          .                .          .          .                  *  not touched in any way.  Managing the pointer is the user's
      .          .          .                .               .          .                .          .          .                  *  responsibility.
      .          .          .                .               .          .                .          .          .                  */
 60,048 ( 0.12%) 3 ( 0.09%) 3 ( 0.11%)       0               0          0           30,024 ( 0.22%) 0          0                 ~vector() _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
105,084 ( 0.21%) 2 ( 0.06%) 1 ( 0.04%)  60,048 ( 0.34%)  3,753 ( 2.15%) 0           15,012 ( 0.11%) 0          0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 60,048 ( 0.12%) 1 ( 0.03%) 1 ( 0.04%)  15,012 ( 0.09%)      0          0           15,012 ( 0.11%) 0          0           		      _M_get_Tp_allocator());
      .          .          .                .               .          .                .          .          .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
 90,072 ( 0.18%) 0          0           45,036 ( 0.26%)      0          0           15,012 ( 0.11%) 0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  %Vector assignment operator.
      .          .          .                .               .          .                .          .          .                  *  @param  __x  A %vector of identical element and allocator types.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  All the elements of @a __x are copied, but any unused capacity in
      .          .          .                .               .          .                .          .          .                  *  @a __x will not be copied.
      .          .          .                .               .          .                .          .          .                  *
-- line 691 ----------------------------------------
-- line 701 ----------------------------------------
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  The contents of @a __x are moved into this %vector (without copying,
      .          .          .                .               .          .                .          .          .                  *  if the allocators permit it).
      .          .          .                .               .          .                .          .          .                  *  Afterwards @a __x is a valid, but unspecified %vector.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  Whether the allocator is moved depends on the allocator traits.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 vector&
      5 ( 0.00%) 0          0                0               0          0                3 ( 0.00%) 0          0                 operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      .          .          .                .               .          .                .          .          .                 {
      1 ( 0.00%) 0          0                0               0          0                1 ( 0.00%) 0          0           	constexpr bool __move_storage =
      .          .          .                .               .          .                .          .          .           	  _Alloc_traits::_S_propagate_on_move_assign()
      .          .          .                .               .          .                .          .          .           	  || _Alloc_traits::_S_always_equal();
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                2 ( 0.00%) 0          0           	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
      1 ( 0.00%) 0          0                1 ( 0.00%)      0          0                0          0          0           	return *this;
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  %Vector list assignment operator.
      .          .          .                .               .          .                .          .          .                  *  @param  __l  An initializer_list.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This function fills a %vector with copies of the elements in the
      .          .          .                .               .          .                .          .          .                  *  initializer list @a __l.
      .          .          .                .               .          .                .          .          .                  *
-- line 724 ----------------------------------------
-- line 803 ----------------------------------------
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // iterators
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns a read/write iterator that points to the first
      .          .          .                .               .          .                .          .          .                  *  element in the %vector.  Iteration is done in ordinary
      .          .          .                .               .          .                .          .          .                  *  element order.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 iterator
 93,504 ( 0.19%) 2 ( 0.06%) 1 ( 0.04%)       0               0          0           46,752 ( 0.35%) 0          0                 begin() _GLIBCXX_NOEXCEPT
187,008 ( 0.38%) 0          0           93,504 ( 0.53%)      0          0           23,376 ( 0.17%) 1 ( 0.00%) 1 ( 0.00%)        { return iterator(this->_M_impl._M_start); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns a read-only (constant) iterator that points to the
      .          .          .                .               .          .                .          .          .                  *  first element in the %vector.  Iteration is done in ordinary
      .          .          .                .               .          .                .          .          .                  *  element order.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 const_iterator
      .          .          .                .               .          .                .          .          .                 begin() const _GLIBCXX_NOEXCEPT
-- line 820 ----------------------------------------
-- line 821 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 { return const_iterator(this->_M_impl._M_start); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns a read/write iterator that points one past the last
      .          .          .                .               .          .                .          .          .                  *  element in the %vector.  Iteration is done in ordinary
      .          .          .                .               .          .                .          .          .                  *  element order.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 iterator
154,056 ( 0.31%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0           77,028 ( 0.57%) 0          0                 end() _GLIBCXX_NOEXCEPT
346,626 ( 0.70%) 2 ( 0.06%) 1 ( 0.04%) 154,056 ( 0.87%)      0          0           38,514 ( 0.29%) 0          0                 { return iterator(this->_M_impl._M_finish); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns a read-only (constant) iterator that points one past
      .          .          .                .               .          .                .          .          .                  *  the last element in the %vector.  Iteration is done in
      .          .          .                .               .          .                .          .          .                  *  ordinary element order.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 const_iterator
      .          .          .                .               .          .                .          .          .                 end() const _GLIBCXX_NOEXCEPT
-- line 838 ----------------------------------------
-- line 910 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 const_reverse_iterator
      .          .          .                .               .          .                .          .          .                 crend() const noexcept
      .          .          .                .               .          .                .          .          .                 { return const_reverse_iterator(begin()); }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // [23.2.4.2] capacity
      .          .          .                .               .          .                .          .          .                 /**  Returns the number of elements in the %vector.  */
      .          .          .                .               .          .                .          .          .                 size_type
145,863 ( 0.29%) 1 ( 0.03%) 0                0               0          0           97,242 ( 0.72%) 0          0                 size() const _GLIBCXX_NOEXCEPT
538,023 ( 1.09%) 3 ( 0.09%) 2 ( 0.07%) 291,726 ( 1.65%)    769 ( 0.44%) 0                0          0          0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**  Returns the size() of the largest possible %vector.  */
      .          .          .                .               .          .                .          .          .                 size_type
 66,956 ( 0.14%) 2 ( 0.06%) 1 ( 0.04%)       0               0          0           33,478 ( 0.25%) 0          0                 max_size() const _GLIBCXX_NOEXCEPT
117,173 ( 0.24%) 0          0           50,217 ( 0.28%)      0          0           33,478 ( 0.25%) 0          0                 { return _S_max_size(_M_get_Tp_allocator()); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Resizes the %vector to the specified number of elements.
      .          .          .                .               .          .                .          .          .                  *  @param  __new_size  Number of elements the %vector should contain.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This function will %resize the %vector to the specified
      .          .          .                .               .          .                .          .          .                  *  number of elements.  If the number is smaller than the
-- line 932 ----------------------------------------
-- line 990 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 { _M_shrink_to_fit(); }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns the total number of elements that the %vector can
      .          .          .                .               .          .                .          .          .                  *  hold before needing to allocate more memory.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 size_type
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                2 ( 0.00%) 0          0                 capacity() const _GLIBCXX_NOEXCEPT
      2 ( 0.00%) 0          0                2 ( 0.00%)      1 ( 0.00%) 0                0          0          0                 { return size_type(this->_M_impl._M_end_of_storage
     10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0                0          0          0           			 - this->_M_impl._M_start); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns true if the %vector is empty.  (Thus begin() would
      .          .          .                .               .          .                .          .          .                  *  equal end().)
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 _GLIBCXX_NODISCARD bool
      .          .          .                .               .          .                .          .          .                 empty() const _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 { return begin() == end(); }
-- line 1008 ----------------------------------------
-- line 1035 ----------------------------------------
      .          .          .                .               .          .                .          .          .                  *  @return  Read/write reference to data.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This operator allows for easy, array-style, data access.
      .          .          .                .               .          .                .          .          .                  *  Note that data access with this operator is unchecked and
      .          .          .                .               .          .                .          .          .                  *  out_of_range lookups are not defined. (For checked lookups
      .          .          .                .               .          .                .          .          .                  *  see at().)
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 reference
666,084 ( 1.34%) 0          0                0               0          0          499,563 ( 3.71%) 0          0                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	__glibcxx_requires_subscript(__n);
923,433 ( 1.86%) 0          0          499,563 ( 2.83%)      0          0                0          0          0           	return *(this->_M_impl._M_start + __n);
333,042 ( 0.67%) 1 ( 0.03%) 1 ( 0.04%) 333,042 ( 1.89%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Subscript access to the data contained in the %vector.
      .          .          .                .               .          .                .          .          .                  *  @param __n The index of the element for which data should be
      .          .          .                .               .          .                .          .          .                  *  accessed.
      .          .          .                .               .          .                .          .          .                  *  @return  Read-only (constant) reference to data.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This operator allows for easy, array-style, data access.
-- line 1055 ----------------------------------------
-- line 1062 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	__glibcxx_requires_subscript(__n);
      .          .          .                .               .          .                .          .          .           	return *(this->_M_impl._M_start + __n);
      .          .          .                .               .          .                .          .          .                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               protected:
      .          .          .                .               .          .                .          .          .                 /// Safety check used only from at().
      .          .          .                .               .          .                .          .          .                 void
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                9 ( 0.00%) 0          0                 _M_range_check(size_type __n) const
      .          .          .                .               .          .                .          .          .                 {
     21 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       6 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	if (__n >= this->size())
      .          .          .                .               .          .                .          .          .           	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
      .          .          .                .               .          .                .          .          .           				       "(which is %zu) >= this->size() "
      .          .          .                .               .          .                .          .          .           				       "(which is %zu)"),
      .          .          .                .               .          .                .          .          .           				   __n, this->size());
      9 ( 0.00%) 0          0                6 ( 0.00%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               public:
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Provides access to the data contained in the %vector.
      .          .          .                .               .          .                .          .          .                  *  @param __n The index of the element for which data should be
      .          .          .                .               .          .                .          .          .                  *  accessed.
      .          .          .                .               .          .                .          .          .                  *  @return  Read/write reference to data.
      .          .          .                .               .          .                .          .          .                  *  @throw  std::out_of_range  If @a __n is an invalid index.
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This function provides for safer data access.  The parameter
      .          .          .                .               .          .                .          .          .                  *  is first checked that it is in the range of the vector.  The
      .          .          .                .               .          .                .          .          .                  *  function throws out_of_range if the check fails.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 reference
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                9 ( 0.00%) 0          0                 at(size_type __n)
      .          .          .                .               .          .                .          .          .                 {
     15 ( 0.00%) 0          0                6 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	_M_range_check(__n);
     15 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       6 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	return (*this)[__n];
      6 ( 0.00%) 0          0                6 ( 0.00%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Provides access to the data contained in the %vector.
      .          .          .                .               .          .                .          .          .                  *  @param __n The index of the element for which data should be
      .          .          .                .               .          .                .          .          .                  *  accessed.
      .          .          .                .               .          .                .          .          .                  *  @return  Read-only (constant) reference to data.
      .          .          .                .               .          .                .          .          .                  *  @throw  std::out_of_range  If @a __n is an invalid index.
      .          .          .                .               .          .                .          .          .                  *
-- line 1104 ----------------------------------------
-- line 1135 ----------------------------------------
      .          .          .                .               .          .                .          .          .           	return *begin();
      .          .          .                .               .          .                .          .          .                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns a read/write reference to the data at the last
      .          .          .                .               .          .                .          .          .                  *  element of the %vector.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 reference
 60,552 ( 0.12%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0           30,276 ( 0.22%) 0          0                 back() _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	__glibcxx_requires_nonempty();
181,656 ( 0.37%) 1 ( 0.03%) 1 ( 0.04%)  15,138 ( 0.09%)      0          0           75,690 ( 0.56%) 0          0           	return *(end() - 1);
 30,276 ( 0.06%) 0          0           30,276 ( 0.17%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Returns a read-only (constant) reference to the data at the
      .          .          .                .               .          .                .          .          .                  *  last element of the %vector.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 const_reference
      .          .          .                .               .          .                .          .          .                 back() const _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
-- line 1155 ----------------------------------------
-- line 1160 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .          .          .                .               .          .                .          .          .                 // DR 464. Suggestion for new member functions in standard containers.
      .          .          .                .               .          .                .          .          .                 // data access
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *   Returns a pointer such that [data(), data() + size()) is a valid
      .          .          .                .               .          .                .          .          .                  *   range.  For a non-empty %vector, data() == &front().
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 _Tp*
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                2 ( 0.00%) 0          0                 data() _GLIBCXX_NOEXCEPT
      8 ( 0.00%) 0          0                5 ( 0.00%)      0          0                1 ( 0.00%) 0          0                 { return _M_data_ptr(this->_M_impl._M_start); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 const _Tp*
      .          .          .                .               .          .                .          .          .                 data() const _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 { return _M_data_ptr(this->_M_impl._M_start); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // [23.2.4.3] modifiers
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  @brief  Add data to the end of the %vector.
-- line 1177 ----------------------------------------
-- line 1179 ----------------------------------------
      .          .          .                .               .          .                .          .          .                  *
      .          .          .                .               .          .                .          .          .                  *  This is a typical stack operation.  The function creates an
      .          .          .                .               .          .                .          .          .                  *  element at the end of the %vector and assigns the given data
      .          .          .                .               .          .                .          .          .                  *  to it.  Due to the nature of a %vector this operation can be
      .          .          .                .               .          .                .          .          .                  *  done in constant time if the %vector has preallocated space
      .          .          .                .               .          .                .          .          .                  *  available.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 void
 75,690 ( 0.15%) 1 ( 0.03%) 0                0               0          0           45,414 ( 0.34%) 0          0                 push_back(const value_type& __x)
      .          .          .                .               .          .                .          .          .                 {
 90,828 ( 0.18%) 1 ( 0.03%) 1 ( 0.04%)  60,552 ( 0.34%) 11,865 ( 6.79%) 0                0          0          0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      .          .          .                .               .          .                .          .          .           	  {
      .          .          .                .               .          .                .          .          .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
 47,383 ( 0.10%) 0          0           27,076 ( 0.15%)      0          0            6,769 ( 0.05%) 0          0           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      .          .          .                .               .          .                .          .          .           				     __x);
 33,845 ( 0.07%) 0          0           20,307 ( 0.12%)      0          0            6,769 ( 0.05%) 0          0           	    ++this->_M_impl._M_finish;
      .          .          .                .               .          .                .          .          .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
      .          .          .                .               .          .                .          .          .           	  }
      .          .          .                .               .          .                .          .          .           	else
 75,321 ( 0.15%) 1 ( 0.03%) 1 ( 0.04%)  25,107 ( 0.14%)      0          0           16,738 ( 0.12%) 0          0           	  _M_realloc_insert(end(), __x);
 52,183 ( 0.11%) 0          0           30,276 ( 0.17%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .                 void
      .          .          .                .               .          .                .          .          .                 push_back(value_type&& __x)
      .          .          .                .               .          .                .          .          .                 { emplace_back(std::move(__x)); }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 template<typename... _Args>
      .          .          .                .               .          .                .          .          .           #if __cplusplus > 201402L
-- line 1207 ----------------------------------------
-- line 1500 ----------------------------------------
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               protected:
      .          .          .                .               .          .                .          .          .                 /**
      .          .          .                .               .          .                .          .          .                  *  Memory expansion handler.  Uses the member allocation function to
      .          .          .                .               .          .                .          .          .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
      .          .          .                .               .          .                .          .          .                  */
      .          .          .                .               .          .                .          .          .                 template<typename _ForwardIterator>
      .          .          .                .               .          .                .          .          .           	pointer
      8 ( 0.00%) 0          0                0               0          0                6 ( 0.00%) 0          0           	_M_allocate_and_copy(size_type __n,
      .          .          .                .               .          .                .          .          .           			     _ForwardIterator __first, _ForwardIterator __last)
      .          .          .                .               .          .                .          .          .           	{
      6 ( 0.00%) 0          0                2 ( 0.00%)      0          0                2 ( 0.00%) 0          0           	  pointer __result = this->_M_allocate(__n);
      .          .          .                .               .          .                .          .          .           	  __try
      .          .          .                .               .          .                .          .          .           	    {
      5 ( 0.00%) 0          0                3 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	      std::__uninitialized_copy_a(__first, __last, __result,
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0                1 ( 0.00%) 0          0           					  _M_get_Tp_allocator());
      2 ( 0.00%) 0          0                1 ( 0.00%)      0          0                0          0          0           	      return __result;
      .          .          .                .               .          .                .          .          .           	    }
      .          .          .                .               .          .                .          .          .           	  __catch(...)
      .          .          .                .               .          .                .          .          .           	    {
      .          .          .                .               .          .                .          .          .           	      _M_deallocate(__result, __n);
      .          .          .                .               .          .                .          .          .           	      __throw_exception_again;
      .          .          .                .               .          .                .          .          .           	    }
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%)      0          0                0          0          0           	}
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Internal constructor functions follow.
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by the range constructor to implement [23.1.1]/9
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus < 201103L
      .          .          .                .               .          .                .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1531 ----------------------------------------
-- line 1569 ----------------------------------------
      .          .          .                .               .          .                .          .          .           	    clear();
      .          .          .                .               .          .                .          .          .           	    __throw_exception_again;
      .          .          .                .               .          .                .          .          .           	  }
      .          .          .                .               .          .                .          .          .           	}
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by the second initialize_dispatch above
      .          .          .                .               .          .                .          .          .                 template<typename _ForwardIterator>
      .          .          .                .               .          .                .          .          .           	void
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                5 ( 0.00%) 0          0           	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
      .          .          .                .               .          .                .          .          .           			    std::forward_iterator_tag)
      .          .          .                .               .          .                .          .          .           	{
      6 ( 0.00%) 0          0                2 ( 0.00%)      0          0                2 ( 0.00%) 0          0           	  const size_type __n = std::distance(__first, __last);
      .          .          .                .               .          .                .          .          .           	  this->_M_impl._M_start
     14 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0                4 ( 0.00%) 0          0           	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
      7 ( 0.00%) 0          0                4 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      2 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	  this->_M_impl._M_finish =
      6 ( 0.00%) 0          0                4 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	    std::__uninitialized_copy_a(__first, __last,
      .          .          .                .               .          .                .          .          .           					this->_M_impl._M_start,
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0                1 ( 0.00%) 0          0           					_M_get_Tp_allocator());
      4 ( 0.00%) 0          0                3 ( 0.00%)      0          0                0          0          0           	}
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by the first initialize_dispatch above and by the
      .          .          .                .               .          .                .          .          .                 // vector(n,value,a) constructor.
      .          .          .                .               .          .                .          .          .                 void
      .          .          .                .               .          .                .          .          .                 _M_fill_initialize(size_type __n, const value_type& __value)
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	this->_M_impl._M_finish =
      .          .          .                .               .          .                .          .          .           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
      .          .          .                .               .          .                .          .          .           					_M_get_Tp_allocator());
      .          .          .                .               .          .                .          .          .                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .                 // Called by the vector(n) constructor.
      .          .          .                .               .          .                .          .          .                 void
     15 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0                9 ( 0.00%) 0          0                 _M_default_initialize(size_type __n)
      .          .          .                .               .          .                .          .          .                 {
      6 ( 0.00%) 0          0                3 ( 0.00%)      0          0                3 ( 0.00%) 3 ( 0.00%) 0           	this->_M_impl._M_finish =
     18 ( 0.00%) 0          0                9 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
     12 ( 0.00%) 0          0                3 ( 0.00%)      0          0                3 ( 0.00%) 0          0           					   _M_get_Tp_allocator());
      9 ( 0.00%) 0          0                6 ( 0.00%)      1 ( 0.00%) 0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Internal assign functions follow.  The *_aux functions do the actual
      .          .          .                .               .          .                .          .          .                 // assignment work for the range versions.
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by the range assign to implement [23.1.1]/9
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1616 ----------------------------------------
-- line 1748 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 // Emplacing an rvalue of the correct type can use _M_insert_rval.
      .          .          .                .               .          .                .          .          .                 iterator
      .          .          .                .               .          .                .          .          .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
      .          .          .                .               .          .                .          .          .                 { return _M_insert_rval(__position, std::move(__v)); }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by _M_fill_insert, _M_insert_aux etc.
      .          .          .                .               .          .                .          .          .                 size_type
 58,583 ( 0.12%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0           41,845 ( 0.31%) 0          0                 _M_check_len(size_type __n, const char* __s) const
      .          .          .                .               .          .                .          .          .                 {
117,166 ( 0.24%) 0          0           25,107 ( 0.14%)      0          0           16,738 ( 0.12%) 0          0           	if (max_size() - size() < __n)
      .          .          .                .               .          .                .          .          .           	  __throw_length_error(__N(__s));
      .          .          .                .               .          .                .          .          .           
133,904 ( 0.27%) 2 ( 0.06%) 2 ( 0.07%)  25,107 ( 0.14%)      0          0           41,845 ( 0.31%) 0          0           	const size_type __len = size() + (std::max)(size(), __n);
 92,059 ( 0.19%) 0          0           41,845 ( 0.24%)      0          0           16,738 ( 0.12%) 0          0           	return (__len < size() || __len > max_size()) ? max_size() : __len;
 25,107 ( 0.05%) 0          0           25,107 ( 0.14%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by constructors to check initial size.
      .          .          .                .               .          .                .          .          .                 static size_type
     24 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0               16 ( 0.00%) 0          0                 _S_check_init_len(size_type __n, const allocator_type& __a)
      .          .          .                .               .          .                .          .          .                 {
     60 ( 0.00%) 3 ( 0.09%) 3 ( 0.11%)       8 ( 0.00%)      0          0               12 ( 0.00%) 0          0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
      .          .          .                .               .          .                .          .          .           	  __throw_length_error(
      .          .          .                .               .          .                .          .          .           	      __N("cannot create std::vector larger than max_size()"));
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0                0          0          0           	return __n;
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)      12 ( 0.00%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 static size_type
 66,972 ( 0.14%) 5 ( 0.16%) 5 ( 0.19%)       0               0          0           33,486 ( 0.25%) 0          0                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
      .          .          .                .               .          .                .          .          .           	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
      .          .          .                .               .          .                .          .          .           	// (even if std::allocator_traits::max_size says we can).
 33,486 ( 0.07%) 0          0                0               0          0           16,743 ( 0.12%) 0          0           	const size_t __diffmax
      .          .          .                .               .          .                .          .          .           	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 66,972 ( 0.14%) 1 ( 0.03%) 1 ( 0.04%)  16,743 ( 0.09%)      0          0           33,486 ( 0.25%) 0          0           	const size_t __allocmax = _Alloc_traits::max_size(__a);
100,458 ( 0.20%) 1 ( 0.03%) 1 ( 0.04%)  16,743 ( 0.09%)      0          0           16,743 ( 0.12%) 0          0           	return (std::min)(__diffmax, __allocmax);
 33,486 ( 0.07%) 0          0           33,486 ( 0.19%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Internal erase functions follow.
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
      .          .          .                .               .          .                .          .          .                 // _M_assign_aux.
      .          .          .                .               .          .                .          .          .                 void
      .          .          .                .               .          .                .          .          .                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
      .          .          .                .               .          .                .          .          .                 {
-- line 1793 ----------------------------------------
-- line 1807 ----------------------------------------
      .          .          .                .               .          .                .          .          .                 _M_erase(iterator __first, iterator __last);
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .               private:
      .          .          .                .               .          .                .          .          .                 // Constant-time move assignment when source object's memory can be
      .          .          .                .               .          .                .          .          .                 // moved, either because the source's allocator will move too
      .          .          .                .               .          .                .          .          .                 // or because the allocators are equal.
      .          .          .                .               .          .                .          .          .                 void
      6 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                4 ( 0.00%) 0          0                 _M_move_assign(vector&& __x, true_type) noexcept
      .          .          .                .               .          .                .          .          .                 {
     16 ( 0.00%) 0          0                1 ( 0.00%)      0          0                4 ( 0.00%) 0          0           	vector __tmp(get_allocator());
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	this->_M_impl._M_swap_data(__x._M_impl);
      5 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0           	__tmp._M_impl._M_swap_data(__x._M_impl);
     10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                3 ( 0.00%) 0          0           	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      4 ( 0.00%) 0          0                3 ( 0.00%)      0          0                0          0          0                 }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 // Do move assignment when it might not be possible to move source
      .          .          .                .               .          .                .          .          .                 // object's memory, resulting in a linear-time operation.
      .          .          .                .               .          .                .          .          .                 void
      .          .          .                .               .          .                .          .          .                 _M_move_assign(vector&& __x, false_type)
      .          .          .                .               .          .                .          .          .                 {
      .          .          .                .               .          .                .          .          .           	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
      .          .          .                .               .          .                .          .          .           	  _M_move_assign(std::move(__x), true_type());
-- line 1829 ----------------------------------------
-- line 1836 ----------------------------------------
      .          .          .                .               .          .                .          .          .           				std::random_access_iterator_tag());
      .          .          .                .               .          .                .          .          .           	    __x.clear();
      .          .          .                .               .          .                .          .          .           	  }
      .          .          .                .               .          .                .          .          .                 }
      .          .          .                .               .          .                .          .          .           #endif
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .                 template<typename _Up>
      .          .          .                .               .          .                .          .          .           	_Up*
      4 ( 0.00%) 0          0                0               0          0                3 ( 0.00%) 0          0           	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
      3 ( 0.00%) 0          0                3 ( 0.00%)      0          0                0          0          0           	{ return __ptr; }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .               .          .                .          .          .                 template<typename _Ptr>
      .          .          .                .               .          .                .          .          .           	typename std::pointer_traits<_Ptr>::element_type*
      .          .          .                .               .          .                .          .          .           	_M_data_ptr(_Ptr __ptr) const
      .          .          .                .               .          .                .          .          .           	{ return empty() ? nullptr : std::__to_address(__ptr); }
      .          .          .                .               .          .                .          .          .           #else
      .          .          .                .               .          .                .          .          .                 template<typename _Up>
-- line 1853 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/alloc_traits.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 451 ----------------------------------------
      .          .          .                .          .          .                .          .          .                 /**
      .          .          .                .          .          .                .          .          .                  *  @brief  Allocate memory.
      .          .          .                .          .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @param  __n  The number of objects to allocate space for.
      .          .          .                .          .          .                .          .          .                  *
      .          .          .                .          .          .                .          .          .                  *  Calls @c a.allocate(n)
      .          .          .                .          .          .                .          .          .                 */
      .          .          .                .          .          .                .          .          .                 _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
 75,366 ( 0.15%) 4 ( 0.13%) 3 ( 0.11%)  16,748 ( 0.09%) 0          0           41,870 ( 0.31%) 0          0                 allocate(allocator_type& __a, size_type __n)
 16,748 ( 0.03%) 0          0           16,748 ( 0.09%) 0          0                0          0          0                 { return __a.allocate(__n); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 /**
      .          .          .                .          .          .                .          .          .                  *  @brief  Allocate memory.
      .          .          .                .          .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @param  __n  The number of objects to allocate space for.
      .          .          .                .          .          .                .          .          .                  *  @param  __hint Aid to locality.
      .          .          .                .          .          .                .          .          .                  *  @return Memory of suitable size and alignment for @a n objects
      .          .          .                .          .          .                .          .          .                  *          of type @c value_type
-- line 468 ----------------------------------------
-- line 483 ----------------------------------------
      .          .          .                .          .          .                .          .          .                  *  @brief  Deallocate memory.
      .          .          .                .          .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @param  __p  Pointer to the memory to deallocate.
      .          .          .                .          .          .                .          .          .                  *  @param  __n  The number of objects space was allocated for.
      .          .          .                .          .          .                .          .          .                  *
      .          .          .                .          .          .                .          .          .                  *  Calls <tt> a.deallocate(p, n) </tt>
      .          .          .                .          .          .                .          .          .                 */
      .          .          .                .          .          .                .          .          .                 static _GLIBCXX20_CONSTEXPR void
100,488 ( 0.20%) 4 ( 0.13%) 2 ( 0.07%)  25,122 ( 0.14%) 0          0           58,618 ( 0.44%) 1 ( 0.00%) 0                 deallocate(allocator_type& __a, pointer __p, size_type __n)
 33,496 ( 0.07%) 0          0           16,748 ( 0.09%) 0          0                0          0          0                 { __a.deallocate(__p, __n); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 /**
      .          .          .                .          .          .                .          .          .                  *  @brief  Construct an object of type `_Up`
      .          .          .                .          .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @param  __p  Pointer to memory of suitable size and alignment for
      .          .          .                .          .          .                .          .          .                  *	       an object of type `_Up`.
      .          .          .                .          .          .                .          .          .                  *  @param  __args Constructor arguments.
      .          .          .                .          .          .                .          .          .                  *
      .          .          .                .          .          .                .          .          .                  *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`
      .          .          .                .          .          .                .          .          .                  *  in C++11, C++14 and C++17. Changed in C++20 to call
      .          .          .                .          .          .                .          .          .                  *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.
      .          .          .                .          .          .                .          .          .                 */
      .          .          .                .          .          .                .          .          .                 template<typename _Up, typename... _Args>
      .          .          .                .          .          .                .          .          .           	static _GLIBCXX20_CONSTEXPR void
272,484 ( 0.55%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0          211,932 ( 1.57%) 0          0           	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
      .          .          .                .          .          .                .          .          .           		  _Args&&... __args)
      .          .          .                .          .          .                .          .          .           	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
      .          .          .                .          .          .                .          .          .           	{
      .          .          .                .          .          .                .          .          .           #if __cplusplus <= 201703L
      .          .          .                .          .          .                .          .          .           	  __a.construct(__p, std::forward<_Args>(__args)...);
      .          .          .                .          .          .                .          .          .           #else
454,140 ( 0.92%) 1 ( 0.03%) 1 ( 0.04%) 105,966 ( 0.60%) 0          0          105,966 ( 0.79%) 0          0           	  std::construct_at(__p, std::forward<_Args>(__args)...);
      .          .          .                .          .          .                .          .          .           #endif
151,380 ( 0.31%) 1 ( 0.03%) 1 ( 0.04%) 105,966 ( 0.60%) 0          0                0          0          0           	}
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 /**
      .          .          .                .          .          .                .          .          .                  *  @brief  Destroy an object of type @a _Up
      .          .          .                .          .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @param  __p  Pointer to the object to destroy
      .          .          .                .          .          .                .          .          .                  *
      .          .          .                .          .          .                .          .          .                  *  Calls @c __a.destroy(__p).
      .          .          .                .          .          .                .          .          .                 */
-- line 524 ----------------------------------------
-- line 535 ----------------------------------------
      .          .          .                .          .          .                .          .          .           	}
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 /**
      .          .          .                .          .          .                .          .          .                  *  @brief  The maximum supported allocation size
      .          .          .                .          .          .                .          .          .                  *  @param  __a  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @return @c __a.max_size()
      .          .          .                .          .          .                .          .          .                 */
      .          .          .                .          .          .                .          .          .                 static _GLIBCXX20_CONSTEXPR size_type
 50,229 ( 0.10%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0           33,486 ( 0.25%) 0          0                 max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      .          .          .                .          .          .                .          .          .                 {
      .          .          .                .          .          .                .          .          .           #if __cplusplus <= 201703L
      .          .          .                .          .          .                .          .          .           	return __a.max_size();
      .          .          .                .          .          .                .          .          .           #else
 16,743 ( 0.03%) 0          0                0          0          0                0          0          0           	return size_t(-1) / sizeof(value_type);
      .          .          .                .          .          .                .          .          .           #endif
 33,486 ( 0.07%) 0          0           33,486 ( 0.19%) 0          0                0          0          0                 }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                 /**
      .          .          .                .          .          .                .          .          .                  *  @brief  Obtain an allocator to use when copying a container.
      .          .          .                .          .          .                .          .          .                  *  @param  __rhs  An allocator.
      .          .          .                .          .          .                .          .          .                  *  @return @c __rhs
      .          .          .                .          .          .                .          .          .                 */
      .          .          .                .          .          .                .          .          .                 static _GLIBCXX20_CONSTEXPR allocator_type
      .          .          .                .          .          .                .          .          .                 select_on_container_copy_construction(const allocator_type& __rhs)
-- line 558 ----------------------------------------
-- line 600 ----------------------------------------
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _Alloc>
      .          .          .                .          .          .                .          .          .               inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
      .          .          .                .          .          .                .          .          .               { }
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _Alloc>
      .          .          .                .          .          .                .          .          .               _GLIBCXX14_CONSTEXPR inline void
      5 ( 0.00%) 0          0                0          0          0                3 ( 0.00%) 0          0               __alloc_on_move(_Alloc& __one, _Alloc& __two)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 typedef allocator_traits<_Alloc> __traits;
      .          .          .                .          .          .                .          .          .                 typedef typename __traits::propagate_on_container_move_assignment __pocma;
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201703L
      .          .          .                .          .          .                .          .          .                 if constexpr (__pocma::value)
      3 ( 0.00%) 0          0                1 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	__one = std::move(__two);
      .          .          .                .          .          .                .          .          .           #else
      .          .          .                .          .          .                .          .          .                 __do_alloc_on_move(__one, __two, __pocma());
      .          .          .                .          .          .                .          .          .           #endif
      3 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #if __cplusplus < 201703L
      .          .          .                .          .          .                .          .          .             template<typename _Alloc>
      .          .          .                .          .          .                .          .          .               inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 using std::swap;
      .          .          .                .          .          .                .          .          .                 swap(__one, __two);
      .          .          .                .          .          .                .          .          .               }
-- line 626 ----------------------------------------
-- line 727 ----------------------------------------
      .          .          .                .          .          .                .          .          .           #else
      .          .          .                .          .          .                .          .          .           	allocator_traits<_Allocator>::destroy(__alloc,
      .          .          .                .          .          .                .          .          .           					      std::__addressof(*__first));
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Tp>
      .          .          .                .          .          .                .          .          .               inline void
140,292 ( 0.28%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0           93,528 ( 0.69%) 0          0               _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      .          .          .                .          .          .                .          .          .           	     allocator<_Tp>&)
      .          .          .                .          .          .                .          .          .               {
116,910 ( 0.24%) 0          0           46,764 ( 0.27%) 0          0           23,382 ( 0.17%) 1 ( 0.00%) 0                 _Destroy(__first, __last);
 70,146 ( 0.14%) 0          0           46,764 ( 0.27%) 1 ( 0.00%) 0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           _GLIBCXX_END_NAMESPACE_VERSION
      .          .          .                .          .          .                .          .          .           } // namespace std
      .          .          .                .          .          .                .          .          .           #endif // _ALLOC_TRAITS_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/allocator.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 136 ----------------------------------------
      .          .          .               .          .          .               .          .          .                 typedef true_type propagate_on_container_move_assignment;
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                 typedef true_type is_always_equal;
      .          .          .               .          .          .               .          .          .           #endif
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .          .          .               .          .          .               .          .          .                 // 3035. std::allocator's constructors should be constexpr
      .          .          .               .          .          .               .          .          .                 _GLIBCXX20_CONSTEXPR
150,100 ( 0.30%) 6 ( 0.19%) 4 ( 0.15%) 45,030 ( 0.26%) 0          0          45,030 ( 0.33%) 0          0                 allocator() _GLIBCXX_NOTHROW { }
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                 _GLIBCXX20_CONSTEXPR
     55 ( 0.00%) 3 ( 0.09%) 3 ( 0.11%)      0          0          0              33 ( 0.00%) 0          0                 allocator(const allocator& __a) _GLIBCXX_NOTHROW
     88 ( 0.00%) 3 ( 0.09%) 2 ( 0.07%)     44 ( 0.00%) 0          0              11 ( 0.00%) 0          0                 : __allocator_base<_Tp>(__a) { }
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #if __cplusplus >= 201103L
      .          .          .               .          .          .               .          .          .                 // Avoid implicit deprecation.
      .          .          .               .          .          .               .          .          .                 allocator& operator=(const allocator&) = default;
      .          .          .               .          .          .               .          .          .           #endif
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                 template<typename _Tp1>
      .          .          .               .          .          .               .          .          .           	_GLIBCXX20_CONSTEXPR
      .          .          .               .          .          .               .          .          .           	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #if __cpp_constexpr_dynamic_alloc
      .          .          .               .          .          .               .          .          .                 constexpr
      .          .          .               .          .          .               .          .          .           #endif
 90,126 ( 0.18%) 3 ( 0.09%) 3 ( 0.11%) 30,042 ( 0.17%) 0          0          30,042 ( 0.22%) 0          0                 ~allocator() _GLIBCXX_NOTHROW { }
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #if __cplusplus > 201703L
      .          .          .               .          .          .               .          .          .                 [[nodiscard,__gnu__::__always_inline__]]
      .          .          .               .          .          .               .          .          .                 constexpr _Tp*
      .          .          .               .          .          .               .          .          .                 allocate(size_t __n)
      .          .          .               .          .          .               .          .          .                 {
      .          .          .               .          .          .               .          .          .           #ifdef __cpp_lib_is_constant_evaluated
 25,122 ( 0.05%) 1 ( 0.03%) 1 ( 0.04%)      0          0          0           8,374 ( 0.06%) 0          0           	if (std::is_constant_evaluated())
      .          .          .               .          .          .               .          .          .           	  return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      .          .          .               .          .          .               .          .          .           #endif
 58,618 ( 0.12%) 4 ( 0.13%) 3 ( 0.11%) 16,748 ( 0.09%) 0          0           8,374 ( 0.06%) 0          0           	return __allocator_base<_Tp>::allocate(__n, 0);
      .          .          .               .          .          .               .          .          .                 }
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                 [[__gnu__::__always_inline__]]
      .          .          .               .          .          .               .          .          .                 constexpr void
      .          .          .               .          .          .               .          .          .                 deallocate(_Tp* __p, size_t __n)
      .          .          .               .          .          .               .          .          .                 {
      .          .          .               .          .          .               .          .          .           #ifdef __cpp_lib_is_constant_evaluated
 25,122 ( 0.05%) 0          0               0          0          0           8,374 ( 0.06%) 0          0           	if (std::is_constant_evaluated())
      .          .          .               .          .          .               .          .          .           	  {
      .          .          .               .          .          .               .          .          .           	    ::operator delete(__p);
      .          .          .               .          .          .               .          .          .           	    return;
      .          .          .               .          .          .               .          .          .           	  }
      .          .          .               .          .          .               .          .          .           #endif
 50,244 ( 0.10%) 1 ( 0.03%) 1 ( 0.04%) 25,122 ( 0.14%) 0          0           8,374 ( 0.06%) 0          0           	  __allocator_base<_Tp>::deallocate(__p, __n);
      .          .          .               .          .          .               .          .          .                 }
      .          .          .               .          .          .               .          .          .           #endif // C++20
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                 friend _GLIBCXX20_CONSTEXPR bool
      .          .          .               .          .          .               .          .          .                 operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW
      .          .          .               .          .          .               .          .          .                 { return true; }
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #if __cpp_impl_three_way_comparison < 201907L
-- line 195 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/utils/vector.hpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw            DLmw            

-- line 13 ----------------------------------------
      .          .          .                .          .          .                .               .               .                   vec3(T _x, T _y, T _z)
      .          .          .                .          .          .                .               .               .                           : x(static_cast<double>(_x)),
      .          .          .                .          .          .                .               .               .                             y(static_cast<double>(_y)),
      .          .          .                .          .          .                .               .               .                             z(static_cast<double>(_z)) {
      .          .          .                .          .          .                .               .               .                   }
      .          .          .                .          .          .                .               .               .           
      .          .          .                .          .          .                .               .               .                   vec3();
      .          .          .                .          .          .                .               .               .           
878,382 ( 1.77%) 3 ( 0.09%) 2 ( 0.07%) 390,392 ( 2.21%) 0          0          390,392 ( 2.90%) 17,754 (11.83%) 14,445 (14.40%)          constexpr vec3(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}
      .          .          .                .          .          .                .               .               .           
      .          .          .                .          .          .                .               .               .                   vec3 operator+(const vec3 &vector) const;
      .          .          .                .          .          .                .               .               .           
      .          .          .                .          .          .                .               .               .                   vec3 operator+=(const vec3 &vector);
      .          .          .                .          .          .                .               .               .           
      .          .          .                .          .          .                .               .               .                   vec3 operator-(const vec3 &vector) const;
      .          .          .                .          .          .                .               .               .           
      .          .          .                .          .          .                .               .               .                   vec3 operator-=(const vec3 &vector);
-- line 29 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw           DLmw           

-- line 222 ----------------------------------------
      .          .          .                .          .          .                .              .              .              *
      .          .          .                .          .          .                .              .              .              *  This is the simple classic generic implementation.  It will work on
      .          .          .                .          .          .                .              .              .              *  temporary expressions, since they are only evaluated once, unlike a
      .          .          .                .          .          .                .              .              .              *  preprocessor macro.
      .          .          .                .          .          .                .              .              .             */
      .          .          .                .          .          .                .              .              .             template<typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX14_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline const _Tp&
 66,972 ( 0.14%) 3 ( 0.09%) 2 ( 0.07%)       0          0          0           50,229 ( 0.37%)     0              0               min(const _Tp& __a, const _Tp& __b)
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 // concept requirements
      .          .          .                .          .          .                .              .              .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      .          .          .                .          .          .                .              .              .                 //return __b < __a ? __b : __a;
100,458 ( 0.20%) 0          0           66,972 ( 0.38%) 0          0                0              0              0                 if (__b < __a)
      .          .          .                .          .          .                .              .              .           	return __b;
 16,743 ( 0.03%) 0          0           16,743 ( 0.09%) 0          0                0              0              0                 return __a;
 33,486 ( 0.07%) 0          0           33,486 ( 0.19%) 0          0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             /**
      .          .          .                .          .          .                .              .              .              *  @brief This does what you think it does.
      .          .          .                .          .          .                .              .              .              *  @ingroup sorting_algorithms
      .          .          .                .          .          .                .              .              .              *  @param  __a  A thing of arbitrary type.
      .          .          .                .          .          .                .              .              .              *  @param  __b  Another thing of arbitrary type.
      .          .          .                .          .          .                .              .              .              *  @return   The greater of the parameters.
      .          .          .                .          .          .                .              .              .              *
      .          .          .                .          .          .                .              .              .              *  This is the simple classic generic implementation.  It will work on
      .          .          .                .          .          .                .              .              .              *  temporary expressions, since they are only evaluated once, unlike a
      .          .          .                .          .          .                .              .              .              *  preprocessor macro.
      .          .          .                .          .          .                .              .              .             */
      .          .          .                .          .          .                .              .              .             template<typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX14_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline const _Tp&
 33,476 ( 0.07%) 0          0                0          0          0           25,107 ( 0.19%)     0              0               max(const _Tp& __a, const _Tp& __b)
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 // concept requirements
      .          .          .                .          .          .                .              .              .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      .          .          .                .          .          .                .              .              .                 //return  __a < __b ? __b : __a;
 50,214 ( 0.10%) 0          0           33,476 ( 0.19%) 0          0                0              0              0                 if (__a < __b)
  4,054 ( 0.01%) 0          0            2,027 ( 0.01%) 0          0                0              0              0           	return __b;
  6,342 ( 0.01%) 0          0            6,342 ( 0.04%) 0          0                0              0              0                 return __a;
 16,738 ( 0.03%) 1 ( 0.03%) 0           16,738 ( 0.09%) 0          0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             /**
      .          .          .                .          .          .                .              .              .              *  @brief This does what you think it does.
      .          .          .                .          .          .                .              .              .              *  @ingroup sorting_algorithms
      .          .          .                .          .          .                .              .              .              *  @param  __a  A thing of arbitrary type.
      .          .          .                .          .          .                .              .              .              *  @param  __b  Another thing of arbitrary type.
      .          .          .                .          .          .                .              .              .              *  @param  __comp  A @link comparison_functors comparison functor@endlink.
      .          .          .                .          .          .                .              .              .              *  @return   The lesser of the parameters.
-- line 270 ----------------------------------------
-- line 305 ----------------------------------------
      .          .          .                .          .          .                .              .              .                 return __a;
      .          .          .                .          .          .                .              .              .               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             // Fallback implementation of the function in bits/stl_iterator.h used to
      .          .          .                .          .          .                .              .              .             // remove the __normal_iterator wrapper. See copy, fill, ...
      .          .          .                .          .          .                .              .              .             template<typename _Iterator>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _Iterator
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                2 ( 0.00%)     0              0               __niter_base(_Iterator __it)
      .          .          .                .          .          .                .              .              .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
      3 ( 0.00%) 0          0                3 ( 0.00%) 0          0                0              0              0               { return __it; }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             // Reverse the __niter_base transformation to get a
      .          .          .                .          .          .                .              .              .             // __normal_iterator back again (this assumes that __normal_iterator
      .          .          .                .          .          .                .              .              .             // is only used to wrap random access iterators, like pointers).
      .          .          .                .          .          .                .              .              .             template<typename _From, typename _To>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _From
      .          .          .                .          .          .                .              .              .               __niter_wrap(_From __from, _To __res)
      .          .          .                .          .          .                .              .              .               { return __from + (__res - std::__niter_base(__from)); }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             // No need to wrap, iterator already has the right type.
      .          .          .                .          .          .                .              .              .             template<typename _Iterator>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _Iterator
      4 ( 0.00%) 0          0                0          0          0                3 ( 0.00%)     0              0               __niter_wrap(const _Iterator&, _Iterator __res)
      3 ( 0.00%) 0          0                3 ( 0.00%) 0          0                0              0              0               { return __res; }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             // All of these auxiliary structs serve two purposes.  (1) Replace
      .          .          .                .          .          .                .              .              .             // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
      .          .          .                .          .          .                .              .              .             // because the input and output ranges are permitted to overlap.)
      .          .          .                .          .          .                .              .              .             // (2) If we're using random access iterators, then write the loop as
      .          .          .                .          .          .                .              .              .             // a for loop with an explicit count.
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _IsMove, bool _IsSimple, typename _Category>
-- line 339 ----------------------------------------
-- line 407 ----------------------------------------
      .          .          .                .          .          .                .              .              .           #endif
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _IsMove>
      .          .          .                .          .          .                .              .              .               struct __copy_move<_IsMove, true, random_access_iterator_tag>
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 template<typename _Tp>
      .          .          .                .          .          .                .              .              .           	_GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .           	static _Tp*
      6 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0                4 ( 0.00%)     0              0           	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
      .          .          .                .          .          .                .              .              .           	{
      .          .          .                .          .          .                .              .              .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .              .              .           	  using __assignable = conditional<_IsMove,
      .          .          .                .          .          .                .              .              .           					   is_move_assignable<_Tp>,
      .          .          .                .          .          .                .              .              .           					   is_copy_assignable<_Tp>>;
      .          .          .                .          .          .                .              .              .           	  // trivial types can have deleted assignment
      .          .          .                .          .          .                .              .              .           	  static_assert( __assignable::type::value, "type is not assignable" );
      .          .          .                .          .          .                .              .              .           #endif
      4 ( 0.00%) 0          0                2 ( 0.00%) 0          0                1 ( 0.00%)     0              0           	  const ptrdiff_t _Num = __last - __first;
      2 ( 0.00%) 0          0                1 ( 0.00%) 0          0                0              0              0           	  if (_Num)
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%) 0          0                1 ( 0.00%)     0              0           	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
      4 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0              0              0           	  return __result + _Num;
      2 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0              0              0           	}
      .          .          .                .          .          .                .              .              .               };
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             // Helpers for streambuf iterators (either istream or ostream).
      .          .          .                .          .          .                .              .              .             // NB: avoid including <iosfwd>, relatively large.
      .          .          .                .          .          .                .              .              .             template<typename _CharT>
      .          .          .                .          .          .                .              .              .               struct char_traits;
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<typename _CharT, typename _Traits>
-- line 436 ----------------------------------------
-- line 455 ----------------------------------------
      .          .          .                .          .          .                .              .              .               typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      .          .          .                .          .          .                .              .              .           				    _CharT*>::__type
      .          .          .                .          .          .                .              .              .               __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
      .          .          .                .          .          .                .              .              .           		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _IsMove, typename _II, typename _OI>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _OI
      6 ( 0.00%) 0          0                0          0          0                4 ( 0.00%)     0              0               __copy_move_a2(_II __first, _II __last, _OI __result)
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 typedef typename iterator_traits<_II>::iterator_category _Category;
      .          .          .                .          .          .                .              .              .           #ifdef __cpp_lib_is_constant_evaluated
      3 ( 0.00%) 0          0                0          0          0                1 ( 0.00%)     0              0                 if (std::is_constant_evaluated())
      .          .          .                .          .          .                .              .              .           	return std::__copy_move<_IsMove, false, _Category>::
      .          .          .                .          .          .                .              .              .           	  __copy_m(__first, __last, __result);
      .          .          .                .          .          .                .              .              .           #endif
      .          .          .                .          .          .                .              .              .                 return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%) 0          0                1 ( 0.00%)     0              0           			      _Category>::__copy_m(__first, __last, __result);
      2 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<typename _Tp, typename _Ref, typename _Ptr>
      .          .          .                .          .          .                .              .              .               struct _Deque_iterator;
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .           _GLIBCXX_END_NAMESPACE_CONTAINER
      .          .          .                .          .          .                .              .              .           
-- line 481 ----------------------------------------
-- line 497 ----------------------------------------
      .          .          .                .          .          .                .              .              .               typename __gnu_cxx::__enable_if<
      .          .          .                .          .          .                .              .              .                 __is_random_access_iter<_II>::__value,
      .          .          .                .          .          .                .              .              .                 _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
      .          .          .                .          .          .                .              .              .               __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _IsMove, typename _II, typename _OI>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _OI
      6 ( 0.00%) 0          0                0          0          0                4 ( 0.00%)     0              0               __copy_move_a1(_II __first, _II __last, _OI __result)
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       5 ( 0.00%) 0          0                1 ( 0.00%)     0              0               { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _IsMove, typename _II, typename _OI>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _OI
      8 ( 0.00%) 0          0                0          0          0                6 ( 0.00%)     0              0               __copy_move_a(_II __first, _II __last, _OI __result)
      .          .          .                .          .          .                .              .              .               {
     20 ( 0.00%) 0          0                3 ( 0.00%) 0          0                5 ( 0.00%)     0              0                 return std::__niter_wrap(__result,
      .          .          .                .          .          .                .              .              .           		std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
      .          .          .                .          .          .                .              .              .           					     std::__niter_base(__last),
      .          .          .                .          .          .                .              .              .           					     std::__niter_base(__result)));
      5 ( 0.00%) 0          0                4 ( 0.00%) 0          0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _IsMove,
      .          .          .                .          .          .                .              .              .           	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
      .          .          .                .          .          .                .              .              .               _OI
      .          .          .                .          .          .                .              .              .               __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      .          .          .                .          .          .                .              .              .           		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      .          .          .                .          .          .                .              .              .           		  _OI);
      .          .          .                .          .          .                .              .              .           
-- line 525 ----------------------------------------
-- line 552 ----------------------------------------
      .          .          .                .          .          .                .              .              .              *  [first,last); the copy_backward function should be used instead.
      .          .          .                .          .          .                .              .              .              *
      .          .          .                .          .          .                .              .              .              *  Note that the end of the output range is permitted to be contained
      .          .          .                .          .          .                .              .              .              *  within [first,last).
      .          .          .                .          .          .                .              .              .             */
      .          .          .                .          .          .                .              .              .             template<typename _II, typename _OI>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _OI
      7 ( 0.00%) 0          0                0          0          0                5 ( 0.00%)     0              0               copy(_II __first, _II __last, _OI __result)
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 // concept requirements
      .          .          .                .          .          .                .              .              .                 __glibcxx_function_requires(_InputIteratorConcept<_II>)
      .          .          .                .          .          .                .              .              .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI,
      .          .          .                .          .          .                .              .              .           	    typename iterator_traits<_II>::value_type>)
      .          .          .                .          .          .                .              .              .                 __glibcxx_requires_can_increment_range(__first, __last, __result);
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .                 return std::__copy_move_a<__is_move_iterator<_II>::__value>
     13 ( 0.00%) 0          0                3 ( 0.00%) 0          0                3 ( 0.00%)     0              0           	     (std::__miter_base(__first), std::__miter_base(__last), __result);
      3 ( 0.00%) 0          0                3 ( 0.00%) 0          0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .              .              .             /**
      .          .          .                .          .          .                .              .              .              *  @brief Moves the range [first,last) into result.
      .          .          .                .          .          .                .              .              .              *  @ingroup mutating_algorithms
      .          .          .                .          .          .                .              .              .              *  @param  __first  An input iterator.
      .          .          .                .          .          .                .              .              .              *  @param  __last   An input iterator.
      .          .          .                .          .          .                .              .              .              *  @param  __result An output iterator.
-- line 578 ----------------------------------------
-- line 860 ----------------------------------------
      .          .          .                .          .          .                .              .              .                 for (; __first != __last; ++__first)
      .          .          .                .          .          .                .              .              .           	*__first = __value;
      .          .          .                .          .          .                .              .              .               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<typename _ForwardIterator, typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline typename
      .          .          .                .          .          .                .              .              .               __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                4 ( 0.00%)     0              0               __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
      .          .          .                .          .          .                .              .              .           	      const _Tp& __value)
      .          .          .                .          .          .                .              .              .               {
      3 ( 0.00%) 0          0                2 ( 0.00%) 0          0                1 ( 0.00%)     0              0                 const _Tp __tmp = __value;
681,213 ( 1.37%) 0          0          408,728 ( 2.32%) 0          0                0              0              0                 for (; __first != __last; ++__first)
408,726 ( 0.82%) 0          0          272,484 ( 1.54%) 0          0          136,242 ( 1.01%) 8,515 ( 5.67%) 8,515 ( 8.49%)  	*__first = __tmp;
      3 ( 0.00%) 0          0                2 ( 0.00%) 1 ( 0.00%) 0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             // Specialization: for char types we can use memset.
      .          .          .                .          .          .                .              .              .             template<typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline typename
      .          .          .                .          .          .                .              .              .               __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
      .          .          .                .          .          .                .              .              .               __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
      .          .          .                .          .          .                .              .              .               {
-- line 882 ----------------------------------------
-- line 905 ----------------------------------------
      .          .          .                .          .          .                .              .              .               void
      .          .          .                .          .          .                .              .              .               __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
      .          .          .                .          .          .                .              .              .           	      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
      .          .          .                .          .          .                .              .              .           	      const _VTp&);
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<typename _FIte, typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline void
      6 ( 0.00%) 0          0                0          0          0                4 ( 0.00%)     0              0               __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
      9 ( 0.00%) 0          0                5 ( 0.00%) 0          0                1 ( 0.00%)     0              0               { std::__fill_a1(__first, __last, __value); }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
      .          .          .                .          .          .                .              .              .               void
      .          .          .                .          .          .                .              .              .               __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      .          .          .                .          .          .                .              .              .           	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      .          .          .                .          .          .                .              .              .           	     const _Tp&);
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             /**
-- line 922 ----------------------------------------
-- line 947 ----------------------------------------
      .          .          .                .          .          .                .              .              .             // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR int
      .          .          .                .          .          .                .              .              .             __size_to_integer(int __n) { return __n; }
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR unsigned
      .          .          .                .          .          .                .              .              .             __size_to_integer(unsigned __n) { return __n; }
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR long
      .          .          .                .          .          .                .              .              .             __size_to_integer(long __n) { return __n; }
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR unsigned long
      6 ( 0.00%) 1 ( 0.03%) 0                3 ( 0.00%) 0          0                2 ( 0.00%)     0              0             __size_to_integer(unsigned long __n) { return __n; }
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR long long
      .          .          .                .          .          .                .              .              .             __size_to_integer(long long __n) { return __n; }
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR unsigned long long
      .          .          .                .          .          .                .              .              .             __size_to_integer(unsigned long long __n) { return __n; }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .           #if defined(__GLIBCXX_TYPE_INT_N_0)
      .          .          .                .          .          .                .              .              .             inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
      .          .          .                .          .          .                .              .              .             __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
-- line 963 ----------------------------------------
-- line 1046 ----------------------------------------
      .          .          .                .          .          .                .              .              .                 static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
      .          .          .                .          .          .                .              .              .           #endif
      .          .          .                .          .          .                .              .              .                 return __fill_n_a1(__first, __n, __value);
      .          .          .                .          .          .                .              .              .               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<typename _OutputIterator, typename _Size, typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _OutputIterator
      6 ( 0.00%) 0          0                0          0          0                4 ( 0.00%)     0              0               __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
      .          .          .                .          .          .                .              .              .           	       std::random_access_iterator_tag)
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .              .              .                 static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
      .          .          .                .          .          .                .              .              .           #endif
      2 ( 0.00%) 0          0                1 ( 0.00%) 0          0                0              0              0                 if (__n <= 0)
      .          .          .                .          .          .                .              .              .           	return __first;
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .                 __glibcxx_requires_can_increment(__first, __n);
      .          .          .                .          .          .                .              .              .           
      9 ( 0.00%) 0          0                4 ( 0.00%) 0          0                1 ( 0.00%)     0              0                 std::__fill_a(__first, __first + __n, __value);
      4 ( 0.00%) 0          0                2 ( 0.00%) 1 ( 0.00%) 0                0              0              0                 return __first + __n;
      2 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             /**
      .          .          .                .          .          .                .              .              .              *  @brief Fills the range [first,first+n) with copies of value.
      .          .          .                .          .          .                .              .              .              *  @ingroup mutating_algorithms
      .          .          .                .          .          .                .              .              .              *  @param  __first  An output iterator.
      .          .          .                .          .          .                .              .              .              *  @param  __n      The count of copies to perform.
      .          .          .                .          .          .                .              .              .              *  @param  __value  A reference-to-const of arbitrary type.
      .          .          .                .          .          .                .              .              .              *  @return   The iterator at first+n.
-- line 1075 ----------------------------------------
-- line 1081 ----------------------------------------
      .          .          .                .          .          .                .              .              .              *  If @p __n is negative, the function does nothing.
      .          .          .                .          .          .                .              .              .             */
      .          .          .                .          .          .                .              .              .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .          .          .                .          .          .                .              .              .             // DR 865. More algorithms that throw away information
      .          .          .                .          .          .                .              .              .             // DR 426. search_n(), fill_n(), and generate_n() with negative n
      .          .          .                .          .          .                .              .              .             template<typename _OI, typename _Size, typename _Tp>
      .          .          .                .          .          .                .              .              .               _GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .               inline _OI
      6 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0                4 ( 0.00%)     0              0               fill_n(_OI __first, _Size __n, const _Tp& __value)
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 // concept requirements
      .          .          .                .          .          .                .              .              .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
      .          .          .                .          .          .                .              .              .           
      9 ( 0.00%) 0          0                3 ( 0.00%) 0          0                2 ( 0.00%)     0              0                 return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
      3 ( 0.00%) 0          0                0          0          0                1 ( 0.00%)     0              0           			       std::__iterator_category(__first));
      2 ( 0.00%) 0          0                2 ( 0.00%) 1 ( 0.00%) 0                0              0              0               }
      .          .          .                .          .          .                .              .              .           
      .          .          .                .          .          .                .              .              .             template<bool _BoolType>
      .          .          .                .          .          .                .              .              .               struct __equal
      .          .          .                .          .          .                .              .              .               {
      .          .          .                .          .          .                .              .              .                 template<typename _II1, typename _II2>
      .          .          .                .          .          .                .              .              .           	_GLIBCXX20_CONSTEXPR
      .          .          .                .          .          .                .              .              .           	static bool
      .          .          .                .          .          .                .              .              .           	equal(_II1 __first1, _II1 __last1, _II2 __first2)
-- line 1104 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/grid/grid.cpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr            DLmr       Dw              D1mw       DLmw       

      .          .          .                .               .          .               .          .          .           #include "grid.hpp"
      .          .          .                .               .          .               .          .          .           
      .          .          .                .               .          .               .          .          .           #include "sim/utils/constants.hpp"
      .          .          .                .               .          .               .          .          .           
      .          .          .                .               .          .               .          .          .           #include <cmath>
      .          .          .                .               .          .               .          .          .           #include <iostream>
      .          .          .                .               .          .               .          .          .           
      .          .          .                .               .          .               .          .          .           namespace sim {
     10 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0               8 ( 0.00%) 0          0               Grid::Grid(int np, double ppm, std::vector<Particle> &particles)
     13 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       7 ( 0.00%)      1 ( 0.00%) 1 ( 0.01%)      1 ( 0.00%) 0          0                       : np_(np), ppm_(ppm), h_(MUL_RAD / ppm_), m_(DENSITY / pow(ppm_, 3)),
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0               0          0          0                         grid_size_({std::floor((TOP_LIMIT.x - BOTTOM_LIMIT.x) / h_),
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0               0          0          0                                     std::floor((TOP_LIMIT.y - BOTTOM_LIMIT.y) / h_),
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0               0          0          0                                     std::floor((TOP_LIMIT.z - BOTTOM_LIMIT.z) / h_)}),
      .          .          .                .               .          .               .          .          .                         block_size_({
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       4 ( 0.00%)      0          0               0          0          0                                             (TOP_LIMIT.x - BOTTOM_LIMIT.x) / grid_size_.x,
      5 ( 0.00%) 0          0                4 ( 0.00%)      0          0               0          0          0                                             (TOP_LIMIT.y - BOTTOM_LIMIT.y) / grid_size_.y,
      5 ( 0.00%) 0          0                4 ( 0.00%)      0          0               0          0          0                                             (TOP_LIMIT.z - BOTTOM_LIMIT.z) / grid_size_.z,
      .          .          .                .               .          .               .          .          .                                     }),
     65 ( 0.00%) 3 ( 0.09%) 3 ( 0.11%)      16 ( 0.00%)      0          0              11 ( 0.00%) 1 ( 0.00%) 0                         blocks_(static_cast<size_t>(grid_size_.x * grid_size_.y * grid_size_.z)) {
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      1 ( 0.00%) 0               1 ( 0.00%) 0          0                   InitMessage();
242,226 ( 0.49%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%)      0          0          60,558 ( 0.45%) 1 ( 0.00%) 0                   for (auto &particle: particles) {
 75,690 ( 0.15%) 0          0           15,138 ( 0.09%)      0          0          30,276 ( 0.22%) 0          0                       size_t const block_index = GetBlockIndex(
 30,276 ( 0.06%) 0          0           15,138 ( 0.09%)      0          0               0          0          0                               particle.position);  // Coger la posicion de la particula comprobar en que bloque le toca
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)      0          0          30,276 ( 0.22%) 0          0                       blocks_[block_index].AddParticle(particle);  // Anadir la particula a dicho bloque
      .          .          .                .               .          .               .          .          .                   }
      7 ( 0.00%) 1 ( 0.03%) 0                5 ( 0.00%)      0          0               0          0          0               }
      .          .          .                .               .          .               .          .          .           
      5 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0               3 ( 0.00%) 0          0               void Grid::InitMessage() const {
     12 ( 0.00%) 0          0                2 ( 0.00%)      1 ( 0.00%) 0               3 ( 0.00%) 0          0                   std::cout << "Number of particles: " << np_ << "\n";
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0               3 ( 0.00%) 0          0                   std::cout << "Particles per meter: " << ppm_ << "\n";
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0               3 ( 0.00%) 0          0                   std::cout << "Smoothing length: " << h_ << "\n";
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0               3 ( 0.00%) 0          0                   std::cout << "Particles Mass: " << m_ << "\n";
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0               3 ( 0.00%) 0          0                   std::cout << "Grid size: " << grid_size_ << "\n";
     14 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0               4 ( 0.00%) 0          0                   std::cout << "Number of blocks: " << blocks_.size() << "\n";
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0               3 ( 0.00%) 0          0                   std::cout << "Block size: " << block_size_ << "\n";
      4 ( 0.00%) 0          0                3 ( 0.00%)      0          0               0          0          0               }
      .          .          .                .               .          .               .          .          .           
      .          .          .                .               .          .               .          .          .               /**
      .          .          .                .               .          .               .          .          .               * Obtiene el índice del bloque al que pertenece una partícula
      .          .          .                .               .          .               .          .          .               *
      .          .          .                .               .          .               .          .          .               * @param particle_pos posición de la partícula en coordenadas x,y,z
      .          .          .                .               .          .               .          .          .               * @return índice del bloque al que pertenece la partícula en la cuadrícula.
      .          .          .                .               .          .               .          .          .               */
 75,690 ( 0.15%) 0          0                0               0          0          45,414 ( 0.34%) 0          0               size_t Grid::GetBlockIndex(vec3 &particle_pos) const {
      .          .          .                .               .          .               .          .          .                   // i,j,k posicion del bloque en la malla --> pasarlo al indice del bloque
181,656 ( 0.37%) 1 ( 0.03%) 1 ( 0.04%)  75,690 ( 0.43%) 11,355 ( 6.50%) 0          30,276 ( 0.22%) 0          0                   double pos_i = std::floor((particle_pos.x - BOTTOM_LIMIT.x) / block_size_.x);
181,656 ( 0.37%) 1 ( 0.03%) 1 ( 0.04%)  75,690 ( 0.43%)  3,784 ( 2.16%) 0          30,276 ( 0.22%) 0          0                   double pos_j = std::floor((particle_pos.y - BOTTOM_LIMIT.y) / block_size_.y);
181,656 ( 0.37%) 1 ( 0.03%) 1 ( 0.04%)  75,690 ( 0.43%)      0          0          30,276 ( 0.22%) 0          0                   double pos_k = std::floor((particle_pos.z - BOTTOM_LIMIT.z) / block_size_.z);
      .          .          .                .               .          .               .          .          .           
      .          .          .                .               .          .               .          .          .                   // Asegura que las coordenadas estén dentro de los límites de la cuadrícula
 45,414 ( 0.09%) 0          0           15,138 ( 0.09%)      0          0               0          0          0                   if (pos_i < 0) {
  1,014 ( 0.00%) 0          0                0               0          0             338 ( 0.00%) 0          0                      pos_i = 0;
 74,000 ( 0.15%) 1 ( 0.03%) 1 ( 0.04%)  44,400 ( 0.25%)      0          0               0          0          0                   } else if (pos_i >= grid_size_.x){
  1,690 ( 0.00%) 0          0            1,014 ( 0.01%)     13 ( 0.01%) 0             338 ( 0.00%) 0          0                      pos_i = grid_size_.x - 1;
      .          .          .                .               .          .               .          .          .                   }
 45,414 ( 0.09%) 0          0           15,138 ( 0.09%)      0          0               0          0          0                   if (pos_j < 0) {
  6,720 ( 0.01%) 0          0                0               0          0           2,240 ( 0.02%) 0          0                       pos_j = 0;
 64,490 ( 0.13%) 0          0           38,694 ( 0.22%)      0          0               0          0          0                   } else if (pos_j >= grid_size_.y){
      .          .          .                .               .          .               .          .          .                       pos_j = grid_size_.y - 1;
      .          .          .                .               .          .               .          .          .                   }
 45,414 ( 0.09%) 1 ( 0.03%) 1 ( 0.04%)  15,138 ( 0.09%)      0          0               0          0          0                   if (pos_k < 0) {
  1,032 ( 0.00%) 0          0                0               0          0             344 ( 0.00%) 0          0                       pos_k = 0;
 73,970 ( 0.15%) 1 ( 0.03%) 1 ( 0.04%)  44,382 ( 0.25%)      0          0               0          0          0                   } else if (pos_k >= grid_size_.z){
  1,735 ( 0.00%) 0          0            1,041 ( 0.01%)     74 ( 0.04%) 1 ( 0.01%)    347 ( 0.00%) 0          0                       pos_k = grid_size_.z - 1;
      .          .          .                .               .          .               .          .          .                   }
 90,828 ( 0.18%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)      0          0               0          0          0                   return (static_cast<size_t>(pos_i) +
211,932 ( 0.43%) 2 ( 0.06%) 2 ( 0.07%)  90,828 ( 0.51%)      0          0               0          0          0                           static_cast<size_t>(pos_j) * static_cast<size_t>(grid_size_.x) +
333,036 ( 0.67%) 3 ( 0.09%) 3 ( 0.11%) 136,242 ( 0.77%)      0          0               0          0          0                           static_cast<size_t>(pos_k) * static_cast<size_t>(grid_size_.x) * static_cast<size_t>(grid_size_.y));
 30,276 ( 0.06%) 0          0           30,276 ( 0.17%)      0          0               0          0          0               }
      .          .          .                .               .          .               .          .          .           
      3 ( 0.00%) 0          0                0               0          0               2 ( 0.00%) 0          0               int Grid::GetNumParticles() const {
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0               0          0          0                   return np_;
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0               0          0          0               }
      .          .          .                .               .          .               .          .          .           
      3 ( 0.00%) 0          0                0               0          0               2 ( 0.00%) 0          0               double Grid::GetParticlesPerMeter() const {
      3 ( 0.00%) 1 ( 0.03%) 0                2 ( 0.00%)      1 ( 0.00%) 1 ( 0.01%)      0          0          0                   return ppm_;
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0               0          0          0               }
      .          .          .                .               .          .               .          .          .           
      3 ( 0.00%) 0          0                0               0          0               2 ( 0.00%) 0          0               std::vector<Block>& Grid::GetBlocks() {
      2 ( 0.00%) 0          0                1 ( 0.00%)      0          0               0          0          0                   return blocks_;
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0               0          0          0               }
     19 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       6 ( 0.00%)      0          0               5 ( 0.00%) 0          0           }  // namespace sim
--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/move.h
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 41 ----------------------------------------
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             // Used, in C++03 mode too, by allocators, etc.
      .          .          .                .          .          .                .          .          .             /**
      .          .          .                .          .          .                .          .          .              *  @brief Same as C++11 std::addressof
      .          .          .                .          .          .                .          .          .              *  @ingroup utilities
      .          .          .                .          .          .                .          .          .              */
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
      .          .          .                .          .          .                .          .          .               inline _GLIBCXX_CONSTEXPR _Tp*
191,025 ( 0.39%) 3 ( 0.09%) 3 ( 0.11%)       0          0          0          127,350 ( 0.95%) 0          0               __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
191,025 ( 0.39%) 0          0          191,025 ( 1.08%) 0          0                0          0          0               { return __builtin_addressof(__r); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           _GLIBCXX_END_NAMESPACE_VERSION
      .          .          .                .          .          .                .          .          .           } // namespace
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #include <type_traits> // Brings in std::declval too.
      .          .          .                .          .          .                .          .          .           
-- line 58 ----------------------------------------
-- line 68 ----------------------------------------
      .          .          .                .          .          .                .          .          .             /**
      .          .          .                .          .          .                .          .          .              *  @brief  Forward an lvalue.
      .          .          .                .          .          .                .          .          .              *  @return The parameter cast to the specified type.
      .          .          .                .          .          .                .          .          .              *
      .          .          .                .          .          .                .          .          .              *  This function is used to implement "perfect forwarding".
      .          .          .                .          .          .                .          .          .              */
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
      .          .          .                .          .          .                .          .          .               constexpr _Tp&&
716,484 ( 1.44%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0          477,656 ( 3.55%) 0          0               forward(typename std::remove_reference<_Tp>::type& __t) noexcept
716,484 ( 1.44%) 0          0          716,484 ( 4.06%) 0          0                0          0          0               { return static_cast<_Tp&&>(__t); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /**
      .          .          .                .          .          .                .          .          .              *  @brief  Forward an rvalue.
      .          .          .                .          .          .                .          .          .              *  @return The parameter cast to the specified type.
      .          .          .                .          .          .                .          .          .              *
      .          .          .                .          .          .                .          .          .              *  This function is used to implement "perfect forwarding".
      .          .          .                .          .          .                .          .          .              */
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
-- line 85 ----------------------------------------
-- line 93 ----------------------------------------
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /**
      .          .          .                .          .          .                .          .          .              *  @brief  Convert a value to an rvalue.
      .          .          .                .          .          .                .          .          .              *  @param  __t  A thing of arbitrary type.
      .          .          .                .          .          .                .          .          .              *  @return The parameter cast to an rvalue-reference to allow moving it.
      .          .          .                .          .          .                .          .          .             */
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
      .          .          .                .          .          .                .          .          .               constexpr typename std::remove_reference<_Tp>::type&&
     12 ( 0.00%) 0          0                0          0          0                8 ( 0.00%) 0          0               move(_Tp&& __t) noexcept
     12 ( 0.00%) 0          0               12 ( 0.00%) 0          0                0          0          0               { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
      .          .          .                .          .          .                .          .          .               struct __move_if_noexcept_cond
      .          .          .                .          .          .                .          .          .               : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
      .          .          .                .          .          .                .          .          .                               is_copy_constructible<_Tp>>::type { };
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             /**
-- line 110 ----------------------------------------
-- line 132 ----------------------------------------
      .          .          .                .          .          .                .          .          .              *  @brief Returns the actual address of the object or function
      .          .          .                .          .          .                .          .          .              *         referenced by r, even in the presence of an overloaded
      .          .          .                .          .          .                .          .          .              *         operator&.
      .          .          .                .          .          .                .          .          .              *  @param  __r  Reference to an object or function.
      .          .          .                .          .          .                .          .          .              *  @return   The actual address.
      .          .          .                .          .          .                .          .          .             */
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
      .          .          .                .          .          .                .          .          .               inline _GLIBCXX17_CONSTEXPR _Tp*
     16 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0                8 ( 0.00%) 0          0               addressof(_Tp& __r) noexcept
     20 ( 0.00%) 0          0               12 ( 0.00%) 0          0                4 ( 0.00%) 0          0               { return std::__addressof(__r); }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .          .          .                .          .          .                .          .          .             // 2598. addressof works on temporaries
      .          .          .                .          .          .                .          .          .             template<typename _Tp>
      .          .          .                .          .          .                .          .          .               const _Tp* addressof(const _Tp&&) = delete;
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             // C++11 version of std::exchange for internal use.
      .          .          .                .          .          .                .          .          .             template <typename _Tp, typename _Up = _Tp>
-- line 149 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_construct.h
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw            DLmw            

-- line 72 ----------------------------------------
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .           namespace std _GLIBCXX_VISIBILITY(default)
        .          .          .                .          .          .                .               .               .           {
        .          .          .                .          .          .                .               .               .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .           #if __cplusplus >= 201703L
        .          .          .                .          .          .                .               .               .             template <typename _Tp>
        .          .          .                .          .          .                .               .               .               _GLIBCXX20_CONSTEXPR inline void
   60,016 ( 0.12%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0           30,008 ( 0.22%)      0               0               destroy_at(_Tp* __location)
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .                 if constexpr (__cplusplus > 201703L && is_array_v<_Tp>)
        .          .          .                .          .          .                .               .               .           	{
        .          .          .                .          .          .                .               .               .           	  for (auto& __x : *__location)
        .          .          .                .          .          .                .               .               .           	    std::destroy_at(std::__addressof(__x));
        .          .          .                .          .          .                .               .               .           	}
        .          .          .                .          .          .                .               .               .                 else
   45,012 ( 0.09%) 0          0           15,004 ( 0.09%) 0          0           15,004 ( 0.11%)      0               0           	__location->~_Tp();
   45,012 ( 0.09%) 1 ( 0.03%) 1 ( 0.04%)  30,008 ( 0.17%) 0          0                0               0               0               }
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .           #if __cplusplus > 201703L
        .          .          .                .          .          .                .               .               .             template<typename _Tp, typename... _Args>
        .          .          .                .          .          .                .               .               .               constexpr auto
  317,898 ( 0.64%) 0          0                0          0          0          257,346 ( 1.91%)      0               0               construct_at(_Tp* __location, _Args&&... __args)
        .          .          .                .          .          .                .               .               .               noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
        .          .          .                .          .          .                .               .               .               -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
  862,866 ( 1.74%) 3 ( 0.09%) 3 ( 0.11%) 317,898 ( 1.80%) 0          0          151,380 ( 1.12%)      0               0               { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
        .          .          .                .          .          .                .               .               .           #endif // C++20
        .          .          .                .          .          .                .               .               .           #endif// C++17
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .             /**
        .          .          .                .          .          .                .               .               .              * Constructs an object in existing memory by invoking an allocated
        .          .          .                .          .          .                .               .               .              * object's constructor with an initializer.
        .          .          .                .          .          .                .               .               .              */
        .          .          .                .          .          .                .               .               .           #if __cplusplus >= 201103L
        .          .          .                .          .          .                .               .               .             template<typename _Tp, typename... _Args>
        .          .          .                .          .          .                .               .               .               inline void
  314,150 ( 0.63%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0          216,824 ( 1.61%)      0               0               _Construct(_Tp* __p, _Args&&... __args)
1,046,639 ( 2.11%) 1 ( 0.03%) 1 ( 0.04%) 265,487 ( 1.50%) 0          0          372,791 ( 2.77%) 32,119 (21.40%) 32,117 (32.01%)      { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
        .          .          .                .          .          .                .               .               .           #else
        .          .          .                .          .          .                .               .               .             template<typename _T1, typename _T2>
        .          .          .                .          .          .                .               .               .               inline void
        .          .          .                .          .          .                .               .               .               _Construct(_T1* __p, const _T2& __value)
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .          .          .                .          .          .                .               .               .                 // 402. wrong new expression in [some_]allocator::construct
        .          .          .                .          .          .                .               .               .                 ::new(static_cast<void*>(__p)) _T1(__value);
-- line 117 ----------------------------------------
-- line 127 ----------------------------------------
        .          .          .                .          .          .                .               .               .               _GLIBCXX20_CONSTEXPR void
        .          .          .                .          .          .                .               .               .               _Destroy(_ForwardIterator __first, _ForwardIterator __last);
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .             /**
        .          .          .                .          .          .                .               .               .              * Destroy the object pointed to by a pointer type.
        .          .          .                .          .          .                .               .               .              */
        .          .          .                .          .          .                .               .               .             template<typename _Tp>
        .          .          .                .          .          .                .               .               .               _GLIBCXX14_CONSTEXPR inline void
   60,016 ( 0.12%) 0          0                0          0          0           30,008 ( 0.22%)      0               0               _Destroy(_Tp* __pointer)
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .           #if __cplusplus > 201703L
   45,012 ( 0.09%) 0          0           15,004 ( 0.09%) 0          0           15,004 ( 0.11%)      0               0                 std::destroy_at(__pointer);
        .          .          .                .          .          .                .               .               .           #else
        .          .          .                .          .          .                .               .               .                 __pointer->~_Tp();
        .          .          .                .          .          .                .               .               .           #endif
   45,012 ( 0.09%) 0          0           30,008 ( 0.17%) 0          0                0               0               0               }
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .             template<bool>
        .          .          .                .          .          .                .               .               .               struct _Destroy_aux
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .                 template<typename _ForwardIterator>
        .          .          .                .          .          .                .               .               .           	static _GLIBCXX20_CONSTEXPR void
        5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                3 ( 0.00%)      0               0           	__destroy(_ForwardIterator __first, _ForwardIterator __last)
        .          .          .                .          .          .                .               .               .           	{
   75,023 ( 0.15%) 0          0           45,014 ( 0.26%) 0          0                0               0               0           	  for (; __first != __last; ++__first)
   75,020 ( 0.15%) 0          0           15,004 ( 0.09%) 0          0           30,008 ( 0.22%)      0               0           	    std::_Destroy(std::__addressof(*__first));
        3 ( 0.00%) 0          0                2 ( 0.00%) 1 ( 0.00%) 0                0               0               0           	}
        .          .          .                .          .          .                .               .               .               };
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .             template<>
        .          .          .                .          .          .                .               .               .               struct _Destroy_aux<true>
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .                 template<typename _ForwardIterator>
        .          .          .                .          .          .                .               .               .                   static void
  163,667 ( 0.33%) 0          0           46,762 ( 0.27%) 0          0           70,143 ( 0.52%)      0               0                   __destroy(_ForwardIterator, _ForwardIterator) { }
        .          .          .                .          .          .                .               .               .               };
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .             /**
        .          .          .                .          .          .                .               .               .              * Destroy a range of objects.  If the value_type of the object has
        .          .          .                .          .          .                .               .               .              * a trivial destructor, the compiler should optimize all of this
        .          .          .                .          .          .                .               .               .              * away, otherwise the objects' destructors must be invoked.
        .          .          .                .          .          .                .               .               .              */
        .          .          .                .          .          .                .               .               .             template<typename _ForwardIterator>
        .          .          .                .          .          .                .               .               .               _GLIBCXX20_CONSTEXPR inline void
  116,910 ( 0.24%) 4 ( 0.13%) 2 ( 0.07%)       0          0          0           70,146 ( 0.52%)      0               0               _Destroy(_ForwardIterator __first, _ForwardIterator __last)
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .                 typedef typename iterator_traits<_ForwardIterator>::value_type
        .          .          .                .          .          .                .               .               .                                  _Value_type;
        .          .          .                .          .          .                .               .               .           #if __cplusplus >= 201103L
        .          .          .                .          .          .                .               .               .                 // A deleted destructor is trivial, this ensures we reject such types:
        .          .          .                .          .          .                .               .               .                 static_assert(is_destructible<_Value_type>::value,
        .          .          .                .          .          .                .               .               .           		    "value type is destructible");
        .          .          .                .          .          .                .               .               .           #endif
        .          .          .                .          .          .                .               .               .           #if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
   70,146 ( 0.14%) 0          0                0          0          0           23,382 ( 0.17%)      0               0                 if (std::is_constant_evaluated())
        .          .          .                .          .          .                .               .               .           	return _Destroy_aux<false>::__destroy(__first, __last);
        .          .          .                .          .          .                .               .               .           #endif
        .          .          .                .          .          .                .               .               .                 std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
  116,910 ( 0.24%) 2 ( 0.06%) 1 ( 0.04%)  46,764 ( 0.27%) 0          0           23,382 ( 0.17%)      0               0           	__destroy(__first, __last);
   46,764 ( 0.09%) 0          0           46,764 ( 0.27%) 0          0                0               0               0               }
        .          .          .                .          .          .                .               .               .           
        .          .          .                .          .          .                .               .               .             template<bool>
        .          .          .                .          .          .                .               .               .               struct _Destroy_n_aux
        .          .          .                .          .          .                .               .               .               {
        .          .          .                .          .          .                .               .               .                 template<typename _ForwardIterator, typename _Size>
        .          .          .                .          .          .                .               .               .           	static _GLIBCXX20_CONSTEXPR _ForwardIterator
        .          .          .                .          .          .                .               .               .           	__destroy_n(_ForwardIterator __first, _Size __count)
        .          .          .                .          .          .                .               .               .           	{
-- line 194 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/../sim/grid/particle.hpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

      .          .          .               .          .          .               .          .          .           #ifndef FLUID_PARTICLE_HPP
      .          .          .               .          .          .               .          .          .           #define FLUID_PARTICLE_HPP
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #include "sim/utils/vector.hpp"
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           namespace sim {
      .          .          .               .          .          .               .          .          .               struct Particle {
348,174 ( 0.70%) 2 ( 0.06%) 2 ( 0.07%) 90,828 ( 0.51%) 0          0          90,828 ( 0.67%) 0          0                   Particle() = default;
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                   Particle(size_t _id, vec3 &_position, vec3 &_hv, vec3 &_velocity);
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                   Particle(const Particle &);
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .                   Particle& operator=(const Particle& other);
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           
-- line 17 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/file/fld.cpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr            DLmr       Dw               D1mw       DLmw       

-- line 15 ----------------------------------------
      .          .          .                .               .          .                .          .          .               ifld::ifld(std::string const &path) : length_(0) {
      .          .          .                .               .          .                .          .          .                   Open(path);
      .          .          .                .               .          .                .          .          .               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Constructor por defecto de la clase, si no se proporciona ningun path, se colocan valores por
      .          .          .                .               .          .                .          .          .                * defecto en length y is_open
      .          .          .                .               .          .                .          .          .                */
     12 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       4 ( 0.00%)      0          0                4 ( 0.00%) 0          0               ifld::ifld() : length_(0) {}
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Destructor de la clase, se asegura de que si el objeto ifld sale de scope el archivo se cierre
      .          .          .                .               .          .                .          .          .                */
      7 ( 0.00%) 2 ( 0.06%) 0                1 ( 0.00%)      0          0                3 ( 0.00%) 0          0               ifld::~ifld() {
      3 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   Close();
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Abre el fichero .fld como archivo binario con permisos de lectura, cambia el valor length
      .          .          .                .               .          .                .          .          .                * @param path: archivo .fld que se desea abrir
      .          .          .                .               .          .                .          .          .                */
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                3 ( 0.00%) 0          0               void ifld::Open(std::string const &path) {  // TODO: Comprobar que el fichero es .fld?
      6 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   if (!input_file_.is_open()) {
      6 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                1 ( 0.00%) 0          0                       input_file_.open(path, std::ios::binary);
      5 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                       input_file_.seekg(0, std::ifstream::end);
     11 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                5 ( 0.00%) 0          0                       length_ = input_file_.tellg();
      5 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                       input_file_.seekg(0, std::ifstream::beg);
      .          .          .                .               .          .                .          .          .                   }
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Cierra el archivo .fld si esta abierto
      .          .          .                .               .          .                .          .          .                */
      4 ( 0.00%) 1 ( 0.03%) 0                0               0          0                2 ( 0.00%) 0          0               void ifld::Close() {
      8 ( 0.00%) 1 ( 0.03%) 0                2 ( 0.00%)      0          0                2 ( 0.00%) 0          0                   if (input_file_.is_open()) { input_file_.close(); }
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Lee el header del archivo y guarda sus valores si son correctos en los parametros
      .          .          .                .               .          .                .          .          .                * @param ppm  Referencia donde se guarda las particulas por metro especificadas en el header
      .          .          .                .               .          .                .          .          .                * @param np Referencia donde se guarda el numero de particulas especificado en el header
      .          .          .                .               .          .                .          .          .                * @return Si el numero de particulas es menor que 0 o no coincide con las particulas encontradas
      .          .          .                .               .          .                .          .          .                * en el archivo se devuelve PARTICLE_NUM_ERR (-5), en caso de exito se devuelve SUCCESS (0)
      .          .          .                .               .          .                .          .          .                */
      6 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                4 ( 0.00%) 0          0               sim::error_code ifld::ReadHeader(double &ppm, int &np) {
      2 ( 0.00%) 0          0                0               0          0                1 ( 0.00%) 0          0                   float tmp = 0.0F;
      .          .          .                .               .          .                .          .          .           
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   input_file_.seekg(0, std::ifstream::beg);
      6 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   input_file_.read(reinterpret_cast<char *>(&tmp), sizeof(float));
      4 ( 0.00%) 0          0                2 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   ppm = static_cast<double>(tmp);
      6 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   input_file_.read(reinterpret_cast<char *>(&np), sizeof(float));
      4 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0                   if (np <= 0) {
      .          .          .                .               .          .                .          .          .                       std::cout << "Invalid number of particles\n";
      .          .          .                .               .          .                .          .          .                       return (PARTICLE_NUM_ERR);
      .          .          .                .               .          .                .          .          .                   }
      .          .          .                .               .          .                .          .          .                   // En cada partícula tenemos 9 números (3 vectores con 3 datos)
      .          .          .                .               .          .                .          .          .                   // si np es distinto del número de floats partido de 9, el número de partículas del header no
      .          .          .                .               .          .                .          .          .                   // coincide con las del archivo
      9 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0                   if (static_cast<size_t>(np) !=
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                0          0          0                       ((length_ - SIZE_HEADER) / sizeof(float)) / PARTICLE_COMPONENTS) {
      .          .          .                .               .          .                .          .          .                       std::cout << "Number of particles mismatch. Header: " << np
      .          .          .                .               .          .                .          .          .                                 << " Found: " << ((length_ - SIZE_HEADER) / 4) / PARTICLE_COMPONENTS << "\n";
      .          .          .                .               .          .                .          .          .                       return (PARTICLE_NUM_ERR);
      .          .          .                .               .          .                .          .          .                   }
      1 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                0          0          0                   return (SUCCESS);
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Lee todas las particulas almacenadas en el fichero inicial
      .          .          .                .               .          .                .          .          .                * @return Devuelve las particulas en un vector (esto no es un problema a partir de la version
      .          .          .                .               .          .                .          .          .                * C++11)
      .          .          .                .               .          .                .          .          .                */
      7 ( 0.00%) 0          0                0               0          0                5 ( 0.00%) 0          0               std::vector<Particle> ifld::ReadParticles() {
      6 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0                2 ( 0.00%) 0          0                   std::vector<Particle> particles;
     19 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%)      0          0                4 ( 0.00%) 0          0                   std::vector<float> tmp((length_ - SIZE_HEADER) / sizeof(float));
      3 ( 0.00%) 0          0                0               0          0                1 ( 0.00%) 0          0                   vec3 position;
      3 ( 0.00%) 0          0                0               0          0                1 ( 0.00%) 0          0                   vec3 vec_hv;
      3 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                1 ( 0.00%) 0          0                   vec3 velocity;
      .          .          .                .               .          .                .          .          .           
     10 ( 0.00%) 0          0                2 ( 0.00%)      1 ( 0.00%) 0                1 ( 0.00%) 0          0                   particles.reserve((length_ - SIZE_HEADER) / 9); // numero de componentes de una particula
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   input_file_.seekg(SIZE_HEADER, std::ifstream::beg);
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%)      0          0                2 ( 0.00%) 0          0                   input_file_.read(reinterpret_cast<char *>(tmp.data()), length_ - SIZE_HEADER);
136,250 ( 0.27%) 0          0           30,277 ( 0.17%)      0          0           15,140 ( 0.11%) 1 ( 0.00%) 0                   for (size_t i = 0; i < tmp.size(); i += PARTICLE_COMPONENTS) {
499,554 ( 1.01%) 3 ( 0.09%) 3 ( 0.11%) 151,380 ( 0.86%)  2,839 ( 1.62%) 0          121,104 ( 0.90%) 0          0                       position = {tmp[i], tmp[i + 1], tmp[i + 2]};
514,692 ( 1.04%) 2 ( 0.06%) 2 ( 0.07%) 151,380 ( 0.86%)  2,839 ( 1.62%) 0          121,104 ( 0.90%) 0          0                       vec_hv = {tmp[i + 3], tmp[i + 4], tmp[i + 5]};
514,692 ( 1.04%) 3 ( 0.09%) 3 ( 0.11%) 151,380 ( 0.86%)  2,838 ( 1.62%) 0          121,104 ( 0.90%) 0          0                       velocity = {tmp[i + 6], tmp[i + 7], tmp[i + 8]};
211,932 ( 0.43%) 1 ( 0.03%) 1 ( 0.04%)  15,138 ( 0.09%)      0          0           30,276 ( 0.22%) 0          0                       particles.emplace_back(i / PARTICLE_COMPONENTS, position, vec_hv, velocity);
      .          .          .                .               .          .                .          .          .                   }
      .          .          .                .               .          .                .          .          .           
      6 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   return (particles);  // NO se si tiene coste creo que no
      6 ( 0.00%) 0          0                5 ( 0.00%)      1 ( 0.00%) 0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Operador booleano de la clase
      .          .          .                .               .          .                .          .          .                * @return Devuelve true si hay un fichero fld abierto y false en caso contrario
      .          .          .                .               .          .                .          .          .                */
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                2 ( 0.00%) 0          0               ifld::operator bool() const {
      3 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   return input_file_.is_open();
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Constructor explicito de la clase cuando se proporciona una path, se abre el archivo
      .          .          .                .               .          .                .          .          .                * directamente con permisos escritura
      .          .          .                .               .          .                .          .          .                * @param path
      .          .          .                .               .          .                .          .          .                */
      .          .          .                .               .          .                .          .          .               ofld::ofld(std::string const &path) {
      .          .          .                .               .          .                .          .          .                   Open(path);
      .          .          .                .               .          .                .          .          .               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Constructor por defecto de ofld
      .          .          .                .               .          .                .          .          .                */
     10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%)      0          0                3 ( 0.00%) 0          0               ofld::ofld() = default;
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Destructor de la clase, se asegura de que si el objeto ofld sale de scope el archivo se cierre
      .          .          .                .               .          .                .          .          .                */
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0                3 ( 0.00%) 0          0               ofld::~ofld() {
      3 ( 0.00%) 1 ( 0.03%) 0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   Close();
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Abre el fichero .fld como archivo binario con permisos de escritura
      .          .          .                .               .          .                .          .          .                * @param path: archivo .fld en el que se desea escribir
      .          .          .                .               .          .                .          .          .                */
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                3 ( 0.00%) 0          0               void ofld::Open(std::string const &path) {
     12 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%)      0          0                2 ( 0.00%) 0          0                   if (!output_file_.is_open()) { output_file_.open(path, std::ios::binary); }
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                * Cierra el archivo .fld si esta abierto
      .          .          .                .               .          .                .          .          .                */
      4 ( 0.00%) 0          0                0               0          0                2 ( 0.00%) 0          0               void ofld::Close() {
      8 ( 0.00%) 0          0                2 ( 0.00%)      0          0                2 ( 0.00%) 0          0                   if (output_file_.is_open()) { output_file_.close(); }
      3 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                *
      .          .          .                .               .          .                .          .          .                * @return
      .          .          .                .               .          .                .          .          .                */
      6 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0                4 ( 0.00%) 0          0               sim::error_code ofld::WriteHeader(int np, double ppm) {
      3 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   auto particle_per_meter = static_cast<float>(ppm);
      6 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   output_file_.write(reinterpret_cast<char*>(&np), sizeof(int));
      6 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   output_file_.write(reinterpret_cast<char*>(&particle_per_meter), sizeof(float));
      1 ( 0.00%) 0          0                0               0          0                0          0          0                   return (SUCCESS);
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                *
      .          .          .                .               .          .                .          .          .                * @return
      .          .          .                .               .          .                .          .          .                */
      6 ( 0.00%) 0          0                0               0          0                4 ( 0.00%) 0          0               sim::error_code ofld::WriteParticles(std::vector<Particle> &particles) {
      5 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0               0          0                5 ( 0.00%) 0          0                   std::array<float,PARTICLE_COMPONENTS> tmp_values{};
242,226 ( 0.49%) 2 ( 0.06%) 2 ( 0.07%)       3 ( 0.00%)      0          0           60,558 ( 0.45%) 1 ( 0.00%) 0                   for(auto& particle : particles) {
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%) 11,354 ( 6.49%) 0           45,414 ( 0.34%) 0          0                       tmp_values[0] = static_cast<float>(particle.position.x);
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)  3,785 ( 2.17%) 0           45,414 ( 0.34%) 0          0                       tmp_values[1] = static_cast<float>(particle.position.y);
166,518 ( 0.34%) 0          0           45,414 ( 0.26%)      0          0           45,414 ( 0.34%) 0          0                       tmp_values[2] = static_cast<float>(particle.position.z);
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)  3,785 ( 2.17%) 0           45,414 ( 0.34%) 0          0                       tmp_values[3] = static_cast<float>(particle.hv.x);
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)      0          0           45,414 ( 0.34%) 0          0                       tmp_values[4] = static_cast<float>(particle.hv.y);
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)  3,784 ( 2.16%) 0           45,414 ( 0.34%) 0          0                       tmp_values[5] = static_cast<float>(particle.hv.z);
166,518 ( 0.34%) 0          0           45,414 ( 0.26%)      0          0           45,414 ( 0.34%) 0          0                       tmp_values[6] = static_cast<float>(particle.velocity.x);
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)  3,784 ( 2.16%) 0           45,414 ( 0.34%) 0          0                       tmp_values[7] = static_cast<float>(particle.velocity.y);
166,518 ( 0.34%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%)      0          0           45,414 ( 0.34%) 0          0                       tmp_values[8] = static_cast<float>(particle.velocity.z);
121,104 ( 0.24%) 0          0           15,138 ( 0.09%)      0          0           30,276 ( 0.22%) 0          0                       output_file_.write(reinterpret_cast<char*>(tmp_values.data()), sizeof(float) * PARTICLE_COMPONENTS);
      .          .          .                .               .          .                .          .          .                   }
      1 ( 0.00%) 0          0                0               0          0                0          0          0                   return (SUCCESS);
      3 ( 0.00%) 0          0                3 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .               /**
      .          .          .                .               .          .                .          .          .                *
      .          .          .                .               .          .                .          .          .                * @return
      .          .          .                .               .          .                .          .          .                */
      4 ( 0.00%) 1 ( 0.03%) 0                0               0          0                2 ( 0.00%) 0          0               ofld::operator bool() const {
      3 ( 0.00%) 0          0                1 ( 0.00%)      0          0                1 ( 0.00%) 0          0                   return output_file_.is_open();
      2 ( 0.00%) 0          0                2 ( 0.00%)      0          0                0          0          0               }
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           
      .          .          .                .               .          .                .          .          .           
     19 ( 0.00%) 3 ( 0.09%) 3 ( 0.11%)       6 ( 0.00%)      0          0                5 ( 0.00%) 0          0           }  // namespace sim
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/grid/block.cpp
--------------------------------------------------------------------------------
Ir              I1mr       ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 6 ----------------------------------------
     .          .          .               .          .          .               .          .          .               /**
     .          .          .               .          .          .               .          .          .               * Agrega una partícula al bloque.
     .          .          .               .          .          .               .          .          .               *
     .          .          .               .          .          .               .          .          .               * @param id Identificador único de la partícula.
     .          .          .               .          .          .               .          .          .               * @param position Posición de la partícula en coordenadas 3D.
     .          .          .               .          .          .               .          .          .               * @param hv Vector de características (hv) de la partícula.
     .          .          .               .          .          .               .          .          .               * @param velocity Vector de velocidad de la partícula.
     .          .          .               .          .          .               .          .          .               */
75,690 ( 0.15%) 1 ( 0.03%) 1 ( 0.04%)      0          0          0          45,414 ( 0.34%) 0          0               void Block::AddParticle(Particle &particle) {
75,690 ( 0.15%) 0          0          30,276 ( 0.17%) 0          0          15,138 ( 0.11%) 0          0                   particles_.push_back(particle);
45,414 ( 0.09%) 0          0          30,276 ( 0.17%) 0          0               0          0          0               }
     .          .          .               .          .          .               .          .          .           
45,012 ( 0.09%) 0          0               0          0          0          30,008 ( 0.22%) 0          0               std::vector<Particle> & Block::GetParticles(){
15,004 ( 0.03%) 1 ( 0.03%) 1 ( 0.04%) 15,004 ( 0.09%) 0          0               0          0          0                   return particles_;
30,008 ( 0.06%) 0          0          30,008 ( 0.17%) 0          0               0          0          0               }
     .          .          .               .          .          .               .          .          .           
     .          .          .               .          .          .               .          .          .           
    19 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)      6 ( 0.00%) 1 ( 0.00%) 0               5 ( 0.00%) 0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/type_traits
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 3284 ----------------------------------------
      .          .          .               .          .          .               .          .          .                 = is_unbounded_array<_Tp>::value;
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .           #define __cpp_lib_is_constant_evaluated 201811L
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .             constexpr inline bool
      .          .          .               .          .          .               .          .          .             is_constant_evaluated() noexcept
200,665 ( 0.40%) 1 ( 0.03%) 1 ( 0.04%) 80,266 ( 0.45%) 0          0          40,133 ( 0.30%) 0          0             { return __builtin_is_constant_evaluated(); }
      .          .          .               .          .          .               .          .          .           #endif
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .             template<typename _From, typename _To>
      .          .          .               .          .          .               .          .          .               using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;
      .          .          .               .          .          .               .          .          .           
      .          .          .               .          .          .               .          .          .             template<typename _Xp, typename _Yp>
      .          .          .               .          .          .               .          .          .               using __cond_res
      .          .          .               .          .          .               .          .          .                 = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());
-- line 3300 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/utils/vector.cpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

      .          .          .                .          .          .                .          .          .           #include "vector.hpp"
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           namespace sim {
      .          .          .                .          .          .                .          .          .               //inicializamos las coordenadas a 0.0 en la clase vec3
908,325 ( 1.83%) 3 ( 0.09%) 1 ( 0.04%) 302,775 ( 1.72%) 0          0          302,775 ( 2.25%) 1 ( 0.00%) 0               vec3::vec3() : x(0.0), y(0.0), z(0.0) {}
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .               /**
      .          .          .                .          .          .                .          .          .                * Suma dos objetos vec3.
      .          .          .                .          .          .                .          .          .                *
      .          .          .                .          .          .                .          .          .                * @param vector segundo objeto vec3 que se sumará a este objeto
      .          .          .                .          .          .                .          .          .                * @return nuevo objeto vec3 resultado de la suma
      .          .          .                .          .          .                .          .          .                */
      .          .          .                .          .          .                .          .          .               vec3 vec3::operator+(const vec3 &vector) const {
-- line 13 ----------------------------------------
-- line 53 ----------------------------------------
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .               /**
      .          .          .                .          .          .                .          .          .                * imprimir un objeto vec3 en un flujo de salida (como std::cout)
      .          .          .                .          .          .                .          .          .                *
      .          .          .                .          .          .                .          .          .                * @param os flujo de salida donde se imprimirá el objeto vec3
      .          .          .                .          .          .                .          .          .                * @param v objeto vec3 que se imprimirá
      .          .          .                .          .          .                .          .          .                * @return flujo de salida después de la operación de impresión
      .          .          .                .          .          .                .          .          .                */
     10 ( 0.00%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0                6 ( 0.00%) 0          0               std::ostream &operator<<(std::ostream &os, const vec3 &v) {
     48 ( 0.00%) 1 ( 0.03%) 0               14 ( 0.00%) 0          0               10 ( 0.00%) 0          0                   os << v.x << " x " << v.y << " x " << v.z;
      2 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0          0          0                   return os;
      4 ( 0.00%) 0          0                4 ( 0.00%) 0          0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/vector.tcc
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 58 ----------------------------------------
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           namespace std _GLIBCXX_VISIBILITY(default)
      .          .          .                .          .          .                .          .          .           {
      .          .          .                .          .          .                .          .          .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
      .          .          .                .          .          .                .          .          .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename _Alloc>
      .          .          .                .          .          .                .          .          .               void
      6 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0                4 ( 0.00%) 0          0               vector<_Tp, _Alloc>::
      .          .          .                .          .          .                .          .          .               reserve(size_type __n)
      .          .          .                .          .          .                .          .          .               {
      7 ( 0.00%) 0          0                2 ( 0.00%) 0          0                1 ( 0.00%) 0          0                 if (__n > this->max_size())
      .          .          .                .          .          .                .          .          .           	__throw_length_error(__N("vector::reserve"));
      7 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%) 0          0                1 ( 0.00%) 0          0                 if (this->capacity() < __n)
      .          .          .                .          .          .                .          .          .           	{
      4 ( 0.00%) 0          0                1 ( 0.00%) 0          0                2 ( 0.00%) 0          0           	  const size_type __old_size = size();
      .          .          .                .          .          .                .          .          .           	  pointer __tmp;
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .           	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
      .          .          .                .          .          .                .          .          .           	    {
      .          .          .                .          .          .                .          .          .           	      __tmp = this->_M_allocate(__n);
      .          .          .                .          .          .                .          .          .           	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
      .          .          .                .          .          .                .          .          .           			  __tmp, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           	    }
      .          .          .                .          .          .                .          .          .           	  else
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .           	    {
     16 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       6 ( 0.00%) 0          0                4 ( 0.00%) 0          0           	      __tmp = _M_allocate_and_copy(__n,
      .          .          .                .          .          .                .          .          .           		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
      .          .          .                .          .          .                .          .          .           		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
      7 ( 0.00%) 0          0                4 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
      4 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       1 ( 0.00%) 0          0                1 ( 0.00%) 0          0           			    _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           	    }
      .          .          .                .          .          .                .          .          .           	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
      8 ( 0.00%) 0          0                3 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	  _M_deallocate(this->_M_impl._M_start,
      2 ( 0.00%) 0          0                2 ( 0.00%) 0          0                0          0          0           			this->_M_impl._M_end_of_storage
      8 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       2 ( 0.00%) 0          0                0          0          0           			- this->_M_impl._M_start);
      3 ( 0.00%) 0          0                2 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	  this->_M_impl._M_start = __tmp;
     10 ( 0.00%) 1 ( 0.03%) 1 ( 0.04%)       3 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	  this->_M_impl._M_finish = __tmp + __old_size;
     10 ( 0.00%) 0          0                4 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      .          .          .                .          .          .                .          .          .           	}
      4 ( 0.00%) 0          0                3 ( 0.00%) 0          0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename _Alloc>
      .          .          .                .          .          .                .          .          .               template<typename... _Args>
      .          .          .                .          .          .                .          .          .           #if __cplusplus > 201402L
      .          .          .                .          .          .                .          .          .                 typename vector<_Tp, _Alloc>::reference
      .          .          .                .          .          .                .          .          .           #else
      .          .          .                .          .          .                .          .          .                 void
      .          .          .                .          .          .                .          .          .           #endif
181,656 ( 0.37%) 1 ( 0.03%) 1 ( 0.04%)       0          0          0          151,380 ( 1.12%) 0          0                 vector<_Tp, _Alloc>::
      .          .          .                .          .          .                .          .          .                 emplace_back(_Args&&... __args)
      .          .          .                .          .          .                .          .          .                 {
 90,828 ( 0.18%) 0          0           60,552 ( 0.34%) 0          0                0          0          0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      .          .          .                .          .          .                .          .          .           	  {
      .          .          .                .          .          .                .          .          .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
363,312 ( 0.73%) 2 ( 0.06%) 2 ( 0.07%) 105,966 ( 0.60%) 0          0           75,690 ( 0.56%) 0          0           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      .          .          .                .          .          .                .          .          .           				     std::forward<_Args>(__args)...);
 90,828 ( 0.18%) 0          0           45,414 ( 0.26%) 0          0           15,138 ( 0.11%) 0          0           	    ++this->_M_impl._M_finish;
      .          .          .                .          .          .                .          .          .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
      .          .          .                .          .          .                .          .          .           	  }
      .          .          .                .          .          .                .          .          .           	else
      .          .          .                .          .          .                .          .          .           	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
      .          .          .                .          .          .                .          .          .           #if __cplusplus > 201402L
 45,414 ( 0.09%) 1 ( 0.03%) 1 ( 0.04%)  15,138 ( 0.09%) 0          0           15,138 ( 0.11%) 0          0           	return back();
      .          .          .                .          .          .                .          .          .           #endif
105,966 ( 0.21%) 0          0           90,828 ( 0.51%) 0          0                0          0          0                 }
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename _Alloc>
      .          .          .                .          .          .                .          .          .               typename vector<_Tp, _Alloc>::iterator
      .          .          .                .          .          .                .          .          .               vector<_Tp, _Alloc>::
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .               insert(const_iterator __position, const value_type& __x)
      .          .          .                .          .          .                .          .          .           #else
-- line 133 ----------------------------------------
-- line 418 ----------------------------------------
      .          .          .                .          .          .                .          .          .                 *__position = std::forward<_Arg>(__arg);
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename _Alloc>
      .          .          .                .          .          .                .          .          .               template<typename... _Args>
      .          .          .                .          .          .                .          .          .                 void
 58,583 ( 0.12%) 2 ( 0.06%) 2 ( 0.07%)       0          0          0           41,845 ( 0.31%) 0          0                 vector<_Tp, _Alloc>::
      .          .          .                .          .          .                .          .          .                 _M_realloc_insert(iterator __position, _Args&&... __args)
      .          .          .                .          .          .                .          .          .           #else
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename _Alloc>
      .          .          .                .          .          .                .          .          .               void
      .          .          .                .          .          .                .          .          .               vector<_Tp, _Alloc>::
      .          .          .                .          .          .                .          .          .               _M_realloc_insert(iterator __position, const _Tp& __x)
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 const size_type __len =
 50,214 ( 0.10%) 0          0            8,369 ( 0.05%) 0          0           16,738 ( 0.12%) 0          0           	_M_check_len(size_type(1), "vector::_M_realloc_insert");
 25,107 ( 0.05%) 0          0           16,738 ( 0.09%) 0          0            8,369 ( 0.06%) 0          0                 pointer __old_start = this->_M_impl._M_start;
 25,107 ( 0.05%) 1 ( 0.03%) 1 ( 0.04%)  16,738 ( 0.09%) 0          0            8,369 ( 0.06%) 0          0                 pointer __old_finish = this->_M_impl._M_finish;
 83,690 ( 0.17%) 0          0            8,369 ( 0.05%) 0          0           33,476 ( 0.25%) 0          0                 const size_type __elems_before = __position - begin();
 50,214 ( 0.10%) 1 ( 0.03%) 1 ( 0.04%)  16,738 ( 0.09%) 0          0           16,738 ( 0.12%) 0          0                 pointer __new_start(this->_M_allocate(__len));
 16,738 ( 0.03%) 0          0            8,369 ( 0.05%) 0          0            8,369 ( 0.06%) 0          0                 pointer __new_finish(__new_start);
      .          .          .                .          .          .                .          .          .                 __try
      .          .          .                .          .          .                .          .          .           	{
      .          .          .                .          .          .                .          .          .           	  // The order of the three operations is dictated by the C++11
      .          .          .                .          .          .                .          .          .           	  // case, where the moves could alter a new element belonging
      .          .          .                .          .          .                .          .          .           	  // to the existing vector.  This is an issue only for callers
      .          .          .                .          .          .                .          .          .           	  // taking the element by lvalue ref (see last bullet of C++11
      .          .          .                .          .          .                .          .          .           	  // [res.on.arguments]).
 92,059 ( 0.19%) 1 ( 0.03%) 1 ( 0.04%)  25,107 ( 0.14%) 0          0           16,738 ( 0.12%) 0          0           	  _Alloc_traits::construct(this->_M_impl,
 50,214 ( 0.10%) 0          0            8,369 ( 0.05%) 0          0                0          0          0           				   __new_start + __elems_before,
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .           				   std::forward<_Args>(__args)...);
      .          .          .                .          .          .                .          .          .           #else
      .          .          .                .          .          .                .          .          .           				   __x);
      .          .          .                .          .          .                .          .          .           #endif
  8,369 ( 0.02%) 0          0                0          0          0            8,369 ( 0.06%) 0          0           	  __new_finish = pointer();
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .           	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
      .          .          .                .          .          .                .          .          .           	    {
      .          .          .                .          .          .                .          .          .           	      __new_finish = _S_relocate(__old_start, __position.base(),
      .          .          .                .          .          .                .          .          .           					 __new_start, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           	      ++__new_finish;
-- line 464 ----------------------------------------
-- line 466 ----------------------------------------
      .          .          .                .          .          .                .          .          .           	      __new_finish = _S_relocate(__position.base(), __old_finish,
      .          .          .                .          .          .                .          .          .           					 __new_finish, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           	    }
      .          .          .                .          .          .                .          .          .           	  else
      .          .          .                .          .          .                .          .          .           #endif
      .          .          .                .          .          .                .          .          .           	    {
      .          .          .                .          .          .                .          .          .           	      __new_finish
      .          .          .                .          .          .                .          .          .           		= std::__uninitialized_move_if_noexcept_a
 83,690 ( 0.17%) 1 ( 0.03%) 1 ( 0.04%)  25,107 ( 0.14%) 0          0           25,107 ( 0.19%) 0          0           		(__old_start, __position.base(),
 33,476 ( 0.07%) 0          0            8,369 ( 0.05%) 0          0            8,369 ( 0.06%) 0          0           		 __new_start, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           
  8,369 ( 0.02%) 0          0            8,369 ( 0.05%) 0          0                0          0          0           	      ++__new_finish;
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           	      __new_finish
      .          .          .                .          .          .                .          .          .           		= std::__uninitialized_move_if_noexcept_a
 83,690 ( 0.17%) 1 ( 0.03%) 1 ( 0.04%)  25,107 ( 0.14%) 0          0           25,107 ( 0.19%) 0          0           		(__position.base(), __old_finish,
 33,476 ( 0.07%) 0          0            8,369 ( 0.05%) 0          0            8,369 ( 0.06%) 0          0           		 __new_finish, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           	    }
      .          .          .                .          .          .                .          .          .           	}
      .          .          .                .          .          .                .          .          .                 __catch(...)
      .          .          .                .          .          .                .          .          .           	{
      .          .          .                .          .          .                .          .          .           	  if (!__new_finish)
      .          .          .                .          .          .                .          .          .           	    _Alloc_traits::destroy(this->_M_impl,
      .          .          .                .          .          .                .          .          .           				   __new_start + __elems_before);
      .          .          .                .          .          .                .          .          .           	  else
      .          .          .                .          .          .                .          .          .           	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .           	  _M_deallocate(__new_start, __len);
      .          .          .                .          .          .                .          .          .           	  __throw_exception_again;
      .          .          .                .          .          .                .          .          .           	}
      .          .          .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .          .          .                .          .          .                .          .          .                 if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
      .          .          .                .          .          .                .          .          .           #endif
 75,321 ( 0.15%) 0          0           25,107 ( 0.14%) 0          0           16,738 ( 0.12%) 0          0           	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      .          .          .                .          .          .                .          .          .                 _GLIBCXX_ASAN_ANNOTATE_REINIT;
 41,845 ( 0.08%) 0          0           16,738 ( 0.09%) 0          0            8,369 ( 0.06%) 0          0                 _M_deallocate(__old_start,
 58,583 ( 0.12%) 1 ( 0.03%) 1 ( 0.04%)  25,107 ( 0.14%) 0          0                0          0          0           		    this->_M_impl._M_end_of_storage - __old_start);
 25,107 ( 0.05%) 0          0           16,738 ( 0.09%) 0          0            8,369 ( 0.06%) 0          0                 this->_M_impl._M_start = __new_start;
 25,107 ( 0.05%) 0          0           16,738 ( 0.09%) 0          0            8,369 ( 0.06%) 0          0                 this->_M_impl._M_finish = __new_finish;
 83,690 ( 0.17%) 1 ( 0.03%) 1 ( 0.04%)  25,107 ( 0.14%) 0          0            8,369 ( 0.06%) 0          0                 this->_M_impl._M_end_of_storage = __new_start + __len;
 33,476 ( 0.07%) 0          0           25,107 ( 0.14%) 0          0                0          0          0               }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .             template<typename _Tp, typename _Alloc>
      .          .          .                .          .          .                .          .          .               void
      .          .          .                .          .          .                .          .          .               vector<_Tp, _Alloc>::
      .          .          .                .          .          .                .          .          .               _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
      .          .          .                .          .          .                .          .          .               {
      .          .          .                .          .          .                .          .          .                 if (__n != 0)
      .          .          .                .          .          .                .          .          .           	{
-- line 513 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/new
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 167 ----------------------------------------
      .          .          .                .          .          .                .          .          .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
      .          .          .                .          .          .                .          .          .           void operator delete[](void*, std::size_t, std::align_val_t)
      .          .          .                .          .          .                .          .          .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
      .          .          .                .          .          .                .          .          .           #endif // __cpp_sized_deallocation
      .          .          .                .          .          .                .          .          .           #endif // __cpp_aligned_new
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           // Default placement versions of operator new.
      .          .          .                .          .          .                .          .          .           _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
552,580 ( 1.11%) 0          0          236,820 ( 1.34%) 0          0          236,820 ( 1.76%) 0          0           { return __p; }
      .          .          .                .          .          .                .          .          .           _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
      .          .          .                .          .          .                .          .          .           { return __p; }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           // Default placement versions of operator delete.
      .          .          .                .          .          .                .          .          .           inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
      .          .          .                .          .          .                .          .          .           inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
      .          .          .                .          .          .                .          .          .           //@}
      .          .          .                .          .          .                .          .          .           } // extern "C++"
-- line 183 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/../sim/utils/vector.hpp
--------------------------------------------------------------------------------
Ir               I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 5 ----------------------------------------
      .          .          .                .          .          .                .          .          .           #include <ostream>
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .           /// Vector de tres dimiensiones
      .          .          .                .          .          .                .          .          .           namespace sim {
      .          .          .                .          .          .                .          .          .               struct vec3 {
      .          .          .                .          .          .                .          .          .                   double x, y, z;
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                   template<typename T>
272,484 ( 0.55%) 0          0                0          0          0          227,070 ( 1.69%) 0          0                   vec3(T _x, T _y, T _z)
 90,828 ( 0.18%) 1 ( 0.03%) 1 ( 0.04%)  45,414 ( 0.26%) 0          0                0          0          0                           : x(static_cast<double>(_x)),
 90,828 ( 0.18%) 0          0           45,414 ( 0.26%) 0          0                0          0          0                             y(static_cast<double>(_y)),
363,312 ( 0.73%) 0          0          181,656 ( 1.03%) 0          0          136,242 ( 1.01%) 0          0                             z(static_cast<double>(_z)) {
136,242 ( 0.27%) 0          0           90,828 ( 0.51%) 0          0                0          0          0                   }
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                   vec3();
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                   constexpr vec3(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                   vec3 operator+(const vec3 &vector) const;
      .          .          .                .          .          .                .          .          .           
      .          .          .                .          .          .                .          .          .                   vec3 operator+=(const vec3 &vector);
-- line 25 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/alumnos/a0432481/ArquiCompP1/sim/grid/particle.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr               D1mr            DLmr       Dw               D1mw            DLmw            

        .          .          .                .               .          .                .               .               .           //
        .          .          .                .               .          .                .               .               .           // Created by alvaro on 11/10/23.
        .          .          .                .               .          .                .               .               .           //
        .          .          .                .               .          .                .               .               .           
        .          .          .                .               .          .                .               .               .           #include "particle.hpp"
        .          .          .                .               .          .                .               .               .           
        .          .          .                .               .          .                .               .               .           namespace sim {
  121,104 ( 0.24%) 2 ( 0.06%) 2 ( 0.07%)       0               0          0           90,828 ( 0.67%)      0               0               Particle::Particle(size_t _id, sim::vec3 &_position, sim::vec3 &_hv, sim::vec3 &_velocity)
        .          .          .                .               .          .                .               .               .                       : id(_id),
        .          .          .                .               .          .                .               .               .                         position(_position),
        .          .          .                .               .          .                .               .               .                         hv(_hv),
        .          .          .                .               .          .                .               .               .                         velocity(_velocity),
        .          .          .                .               .          .                .               .               .                         acceleration({0.0, 0.0, 0.0}),
  560,106 ( 1.13%) 2 ( 0.06%) 2 ( 0.07%) 287,622 ( 1.63%)      0          0          181,656 ( 1.35%) 18,923 (12.61%) 18,923 (18.86%)                density(0) {
   45,414 ( 0.09%) 0          0           30,276 ( 0.17%)      0          0                0               0               0               }
        .          .          .                .               .          .                .               .               .           
  168,295 ( 0.34%) 1 ( 0.03%) 0                0               0          0          100,977 ( 0.75%)      0               0               Particle::Particle(const sim::Particle &other)
   67,318 ( 0.14%) 1 ( 0.03%) 1 ( 0.04%)  67,318 ( 0.38%) 13,702 ( 7.84%) 0                0               0               0                       : id(other.id),
        .          .          .                .               .          .                .               .               .                         position(other.position),
        .          .          .                .               .          .                .               .               .                         hv(other.hv),
        .          .          .                .               .          .                .               .               .                         velocity(other.velocity),
        .          .          .                .               .          .                .               .               .                         acceleration({0.0, 0.0, 0.0}),
1,211,724 ( 2.44%) 2 ( 0.06%) 2 ( 0.07%) 605,862 ( 3.43%) 27,849 (15.93%) 0          403,908 ( 3.00%) 32,318 (21.53%) 22,223 (22.15%)                density(0) {
  100,977 ( 0.20%) 0          0           67,318 ( 0.38%)      0          0                0               0               0               }
        .          .          .                .               .          .                .               .               .           
   60,552 ( 0.12%) 0          0                0               0          0           45,414 ( 0.34%)      0               0               Particle& Particle::operator=(const Particle& other) {
   45,414 ( 0.09%) 0          0           30,276 ( 0.17%)      0          0                0               0               0                   if(this != &other){
   60,552 ( 0.12%) 0          0           45,414 ( 0.26%)      0          0           15,138 ( 0.11%) 14,886 ( 9.92%)      0                       id = other.id;
  121,104 ( 0.24%) 1 ( 0.03%) 1 ( 0.04%)  75,690 ( 0.43%)  3,800 ( 2.17%) 2 ( 0.02%)  45,414 ( 0.34%)  3,785 ( 2.52%)      0                       position = other.position;
  121,104 ( 0.24%) 0          0           75,690 ( 0.43%)  7,562 ( 4.33%) 8 ( 0.08%)  45,414 ( 0.34%)  7,569 ( 5.04%)      0                       hv = other.hv;
  121,104 ( 0.24%) 1 ( 0.03%) 1 ( 0.04%)  75,690 ( 0.43%)  3,776 ( 2.16%) 3 ( 0.03%)  45,414 ( 0.34%)  3,646 ( 2.43%)      0                       velocity = other.velocity;
        .          .          .                .               .          .                .               .               .                   }
   15,138 ( 0.03%) 0          0           15,138 ( 0.09%)      0          0                0               0               0                   return *this;
   30,276 ( 0.06%) 0          0           30,276 ( 0.17%)      0          0                0               0               0               }
        .          .          .                .               .          .                .               .               .           }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/dl-addr.c
  ./elf/dl-lookup.c
  ./elf/do-rel.h
  ./malloc/malloc.c
  ./math/../sysdeps/x86_64/fpu/multiarch/s_floor-sse4_1.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/strcmp.S

--------------------------------------------------------------------------------
Ir                  I1mr         ILmr         Dr                  D1mr             DLmr           Dw                  D1mw             DLmw            
--------------------------------------------------------------------------------
42,790,254 (86.29%) 394 (12.34%) 342 (12.79%) 15,664,032 (88.79%) 142,690 (81.62%) 1,045 (10.69%) 12,613,025 (93.64%) 139,528 (92.97%) 96,224 (95.90%)  events annotated

